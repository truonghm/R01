[
["index.html", "Giới thiệu ngắn gọn về ngôn ngữ R - Phần 1 Mở đầu Disclaimer Outline draft To-do General resources", " Giới thiệu ngắn gọn về ngôn ngữ R - Phần 1 Truong Hoang November 11, 2019 Mở đầu These documents are my personal notes for the R language. They will be brief, enough to get going with data analysis and statistics. These notes will be in both English and Vietnamese (and obviously predominantly Vietnamese), because of multiple reasons that I’m still too lazy to list here (but I will come back later). The language also tends to be casual and colloquial, not formal, because this is not a textbook. Tài liệu chia ra làm 2 phần (đây sẽ là phần 1): phần 1 giới thiệu R ở mức độ cơ bản và bỏ qua 1 số chi tiết phức tạp hơn, nhưng vẫn cố gắng giải thích đi sâu nhất có thể (ví dụ như logic phía sau của 1 function); phần 2 sẽ đi sâu hơn về R nhưng vẫn dừng ở mức ngắn gọn và đầy đủ nhất có thể (data structures, user-defined functions, string manipulation, date &amp; time, more advanced dplyr, automation, apply, functional programming with purrr, etc). Disclaimer I have no formal education in programming or mathematics. Mình không phải chuyên gia về R; thực tế là trong quá trình viết tài liệu, mình cũng phải tự đọc và nghiên cứu thêm rất nhiều. Vì vậy mới nói đây sẽ là personal notes nhằm phục vụ cho việc học của chính mình là trên hết. Hiện tại mình chưa biết cách dùng citation trong R Markdown/bookdown, tuy nhiên mình sẽ luôn bao gồm thêm 1 mục tham khảo ở cuối mỗi chương để trích dẫn các nguồn mà mình sử dụng trong bài và cung cấp tài liệu đọc thêm. Outline draft Các mảng kiến thức chính 1.1. Làm quen với R - 100% 1.1.1. Sử dụng R để tính toán cơ bản (và giới thiệu về function) 1.1.2. Gán biến (assignment) 1.1.3. Vectors 1.1.4. Các gói thư viện (packages) 1.1.5. Tìm kiếm câu trả lời 1.1.6. Workflow trong R 1.1.7. Tham khảo 1.2. Data frame - 95% 1.2.1. Nhập dữ liệu (import data) 1.2.2. Các loại dữ liệu (value type) 1.2.3. Truy vấn dữ liệu cơ bản 1.2.4. Tham khảo 1.3. Vẽ biểu đồ - 60% 1.3.1. Các loại biểu đồ cơ bản 1.3.2. Tiêu đề và đặt tên trục 1.3.3. Dán nhãn dữ liệu (annotation) 1.3.4. Facet 1.3.5. Tổng hợp thuật ngữ 1.3.6. Tham khảo 1.4. Biến đổi dữ liệu (wrangling) - 100% 1.4.1. Giới thiệu chung 1.4.2. Các verb trong dplyr 1.4.3. Basic transformation 1.4.4. Ví dụ thêm 1.4.5. Tham khảo 1.5. Biến đổi dữ liệu phần 2 - 0% 1.6. Control flow (giới thiệu về if-else, for-loop, etc.) - 90% Misc 2.1. FAQs 2.2. Tricks 2.2.1. Kết nối với SQL server 2.2.2. Liệt kê các file trong thư mục 2.2.3. apply/lappy/sapply/tapply 2.2.4. Tương tác với Excel 2.2.5. Làm presentation 2.2.6. Some basic string manipulation functions 2.2.7. Some basic stats functions To-do Hoàn thành tất cả trước 20191031 Bổ sung về projects trong phần Workflow 1.1.6 Hoàn thành phần 1.3 Bổ sung ví dụ về import data mục 1.2.1 Bổ sung về ví dụ if trong 1.5.1.3 Tự tạo dummy data để làm ví dụ Bổ sung thêm chương wrangling nâng cao (giới thiệu các loại join) General resources R for Data Science - Hadley Wickham R Markdown: Thhe Definitive Guide - Yihui Xie bookdown: Authoring Books and Technical Documents with R Markdown - Yihui Xie Git and RStudio Advaned R - Hadley Wickham "],
["lam-quen-vi-r.html", "1 Làm quen với R 1.1 Tính toán cơ bản trong R 1.2 Gán biến (Assignment) 1.3 Vector 1.4 Các gói thư viện (packages) 1.5 Tìm kiếm câu trả lời 1.6 Workflow cơ bản trong R 1.7 Tham khảo", " 1 Làm quen với R R là một ngôn ngữ lập trình open-source (mã nguồn mở) thường được sử dụng trong xác suất thống kê và phân tích dữ liệu. Ngôn ngữ R hoàn toàn miễn phí, có thể cài đặt và sử dụng trên hầu hết mọi hệ điều hành, và có thể tải xuống từ www.r-project.org. R được tạo ra bởi những người học và làm về thống kê, và được tập trung rất kĩ vào mục đích này. Sau khi cài đặt R từ đường link trên, người dùng có thể sử dụng ngôn ngữ này ngay lập tức từ R-GUI (giao diện GUI của R), tuy nhiên giao diện này khá thô sơ. Tốt nhất, người dùng nên cài thêm RSudio (tải xuống từ rstudio.com). RStudio là 1 IDE (Integrated Development Environment) có thể cài trên Windows và Mac, và là IDE phổ biến nhất để lập trình R. R chạy được dựa trên các script (tập lệnh), và không có giao diện dùng trỏ chuột như SAS/Stata/SPSS, vì vậy việc học R ban đầu sẽ khó hơn. Tuy nhiên, nhờ workflow dựa vào các script và project, người dùng sẽ dễ dàng chia sẻ code R cho người khác hơn, vì người đó có thể dựng lại hoàn toàn quy trình nghiên cứu/phân tích trong R bằng các script/project này. RStudio có 4 cửa sổ chính như sau: Góc trên bên trái: Script Góc dưới bên trái: console Góc trên bên phải: Environment/History/Connections Góc dưới bên phải: Files/Plots/Help (3 cái này quan trọng nhất) 1.1 Tính toán cơ bản trong R R có thể sử dụng để tính toán cơ bản bằng cách chạy code từ console (cửa sổ mặc định bên dưới, tay trái trong RStudio, gõ code từ dấu &gt;) như sau: # phép cộng 173+179 ## [1] 352 # phép trừ 173-179 ## [1] -6 # phép nhân 179*173 ## [1] 30967 #phép chia 179/173 ## [1] 1.034682 Tương tự với các phép tính phức tạp hơn: 17^9 ## [1] 118587876497 exp(1) # exponetial function - hàm mũ ## [1] 2.718282 pi # 3.14159265... ## [1] 3.141593 sin(0) ## [1] 0 log(5) # nếu không chỉ định rõ cơ số, R sẽ lấy cơ số là e ## [1] 1.609438 log(5, base=10) # base 10 ## [1] 0.69897 Các function trong R khi được gọi ra luôn có các argument (tham số, viết tắt là arg), trong số một số arg là bắt buộc, một số không, và các arg được tách biệt bằng dấu phẩy. Trong ví dụ trên, hàm log yêu cầu tối thiểu 1 arg là giá trị để lấy giá trị nghịch đảo lũy thừa. Arg base là tham số không bắt buộc, và nếu không chỉ rõ, R sẽ dùng giá trị mặc định (default value) được định nghĩa sẵn trong hàm, ở trường hợp này là \\(e\\). Người dùng có thể đọc thêm về hàm log bằng cách gõ help(log) hoặc ?log ở console. Phần giải thích (documentation) sẽ hiện ra ở cửa sổ góc dưới bên phải. Trong trường hợp của hàm log, 2 arg đầu tiên (và duy nhất) là: x: a numeric or complex vector -&gt; giá trị lấy logarit base: a positive or complex number: the base with respect to which logarithms are computed. Defaults to e=exp(1) -&gt; cơ số Các arg có thứ tự được định nghĩa sẵn theo hàm. Nếu người dùng không chỉ rõ tên của arg, ví dụ: base=10, R sẽ tự hiểu giá trị đưa vào hàm đầu tiên là cho x, giá trị thứ 2 là cho base. log(3, 10) ## [1] 0.4771213 log(10, 3) ## [1] 2.095903 Nếu có chỉ rõ tên của arg, thứ tự đưa vào hàm không còn quan trọng nữa: log(x=3, base=10) ## [1] 0.4771213 log(base=10, x=3) ## [1] 0.4771213 Chú ý: khi đặt giá trị cho tham số, phải sử dụng cú pháp arg_name=value, không phải ngược lại. Đồng thời, dấu = trong trường hợp này được sử dụng để gán giá trị tạm thời, vì vậy không sử dụng dấu &lt;- (sẽ nói ở phần sau). 1.2 Gán biến (Assignment) R sử dụng &lt;- và = để gán biến (assign value to a variable). Hai cách gán biến này khác nhau như sau (trích từ nguồn): The operators &lt;- and = assign into the environment in which they are evaluated. The operator &lt;- can be used anywhere, whereas the operator = is only allowed at the top level (e.g., in the complete expression typed at the command prompt) or as one of the subexpressions in a braced list of expressions. Bạn đọc vui lòng google để hiểu rõ hơn = )). Tuy nhiên, bài học rút ra là: chỉ sử dụng dấu bằng = để khai báo tham số trong hàm, còn các trường hợp gán biến khác thì luôn dùng &lt;-. Tên hàm không thể bắt đầu bằng số, không được bao gồm khoảng trống, và có phân biệt giữa viết hoa và viết thường (case-sensitive). test_var &lt;- 100 Biến đã được khai báo sẽ hiện ra ở phần Environment (góc trên bên phải). 1.3 Vector Vector là một phần tất yếu trong R, và cũng là một trong những thứ khiến R có khả năng khai phá dữ liệu cực kì mạnh mẽ. Trong R, mọi thứ đều là một vector. Ví dụ, khi chúng ta khai báo x &lt;- 7 hoặc x = 7, R sẽ hiểu rằng x đã nhận một vector có độ dài bằng 1. Tuy nhiên, các ngôn ngữ khác sẽ chỉ hiểu biến x đã nhận giá trị 7 mà thôi. Để tạo 1 vector, ta sử dụng hàm c(): x &lt;- c(1,7,9) y &lt;- c(1,7,3) Ở phần 1.1, khi chúng ta dùng R để tính toán phép cộng của 2 giá trị, thực chất R đã làm phép cộng giữa 2 vector có độ dài = 1. Như vậy, hoàn toàn có thể lấy 2 biến x và y vừa gán ở trên để làm phép cộng. x &lt;- c(1,7,9) y &lt;- c(1,7,3) x+y ## [1] 2 14 12 Tương tự, có thể áp dụng với hàm log: log(c(1,2,3), base=10) ## [1] 0.0000000 0.3010300 0.4771213 R còn có thể tạo ra vector là dãy số nguyên liên tục bằng cách viết A:B để tạo vector bắt đầu từ A, tăng 1 dần đều và kết thúc ở B: 1:7 ## [1] 1 2 3 4 5 6 7 Vì tính chất “vectorized” này của R, việc sử dụng vòng lặp (như for loop) giống trong 1 số ngôn ngữ khác (như VBA) là gần như không cần thiết, có thể khiến code chậm đi, trừ trong những trường hợp đặc biệt (sẽ lấy ví dụ sau). 1.4 Các gói thư viện (packages) Giống 1 số ngôn ngữ khác như Python, người dùng R có thể cài đặt thêm các thư viện bổ sung (gọi là package hoặc library) để thực hiện các công việc phức tạp hơn. Một trong số những package phổ biến nhất là dplyr, nằm trong nhóm các thư viện tidyverse. tidyverse cho phép người dùng khai phá dữ liệu mạnh mẽ và tiện dụng hơn, cũng như rất dễ học. Người ta thường gọi R cơ bản là base R, để phân biệt với tidyverse R. Tác giả của tidyverse là Hadley Wickham, và người dùng R có thể tham khảo thêm cuốn R for Data Science cũng có tác giả là Hadkey để hiểu hơn về tidyverse. Các package được cài đặt bằng cách vào menu Tools -&gt; Install Packages..., hoặc gõ hàm install.packages() vào console. Nếu muốn cài đặt nhiều package cùng 1 lúc, ta có thể dùng thêm hàm c(): install.packages(c(&#39;dplyr&#39;, &#39;ggplot2&#39;)) Ngoài các thư viện để bổ sung hàm mới, một số package còn cung cấp cho người dùng các bộ dữ liệu mẫu để phục vụ việc học và thí nghiệm, ví dụ như package nycflights13 library(nycflights13) head(flights,10) ## # A tibble: 10 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ... with 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; 1.5 Tìm kiếm câu trả lời Khi lập trình, chúng ta có thể gặp phải những từng huống mà chưa ai gặp bao giờ, hoặc không có trong sách vở. Vì vậy, đặc biệt là khi tự học, việc tự tìm tòi từ nhiều nguồn là rất cần thiết. 1.5.1 Documentation của R Mọi ngôn ngữ lập trình đều có một documentation, ghi chép lại đầy đủ ý nghĩa của từng hàm, cách sử dụng và cả ví dụ. Vì vậy, khi không hiểu một hàm nên dùng như thế nào, việc đầu tiên là tra cứu documentation có sẵn bằng cách gõ help(tên_hàm) hoặc ?tên_hàm vào console. Phần giải thích sẽ hiện ra ở cửa sổ góc dưới bên phải, mục Help, trong đó thường có các phần: Description: Miêu tả hàm Usage: Ví dụ Arguments: Các tham số và giải thích Details: giải thích cụ thể các tham số Và 1 số mục khác. Ngoài ra, bạn hoàn toàn có thể sử dụng Google để tra cứu chính bản documentation này ở trên mạng. Ngoài các hàm, documentation cũng có cả giải thích cho các package. Tuy nhiên, phần giải thích này có thể không đầy đủ, và lúc đấy, bạn nên chuyển sang dùng Google, với từ khóa như “R package ABCD”. Chú ý, documentation đã được cài sẵn (built-in) theo R, vì vậy không cần kết nối với internet để sử dụng. 1.5.2 Stackoverflow Đối với các vấn đề cụ thể khác, bạn có thể sử dụng Google để tìm kiếm, và thường các kết quả đầu tiên trả về sẽ đến từ trang Stackoverflow. Khi đọc câu trả lời ở đây, tốt nhất bạn nên dành thời gian và hiểu rõ đoạn code có sẵn, thay vì copy về để sử dụng luôn. Ngoài ra, khi copy code về, hãy comment lại phía trên (sử dụng dấu thăng # ở đầu) nguồn gốc của code để sau này khi kiểm tra/debug, có thể dễ dàng tra cứu nguồn gốc. # ví dụ về comment 1.6 Workflow cơ bản trong R Trong các phần trên, chúng ta chủ yếu lấy ví dụ bằng cách nhập code trực tiếp vào console và đưa ra kết quả ngay sau mỗi dòng lệnh. Việc này cũng không khác sử dụng máy tính bỏ túi, vốn không tiện lợi cho lắm. Để khiến việc sử dụng R dễ dàng và hiệu quả hơn, chúng ta có thể sử dụng R script, R Markdown hoặc R Notebook, trong đó hai định dạng phổ biến nhất là Script và Markdown (Tài liệu này cũng được soạn thảo bằng R Markdown). R Script là một dạng “văn bản” để lưu lại các câu lệnh đã soạn thảo, sau đó chúng ta có thể chạy (run) toàn bộ script này để đưa ra kết quả cuối cùng, thay vì chạy từng dòng lệnh từ console, hoặc thậm chí chạy từng phần một của script. Tuy nhiên, R Script chỉ có thể lưu chữ được code và các comment đi kèm, và không có khả năng trình bày, phân tách để tạo ra báo cáo/nghiên cứu hoàn chỉnh. Vì vậy R Script phù hợp với các quy trình làm việc/nghiên cứu nội bộ, không cần trình bày/xuất bản ra ngoài. # ví dụ về comment: có thể dùng để giải thích ý nghĩa đoạn code ở dưới # nguồn tham khảo của code # ghi chú khác x &lt;- 1+1*2-3/4 R Markdown là một dạng của ngôn ngữ Markdown (Đọc thêm về Markdown ở wiki). Ở đây mình sẽ không giải thích cụ thể về R Markdown (tham khảo tại website của RStudio), chỉ nêu ra 1 số điểm lợi như sau: Biến code và phân tích thành một văn bản/báo cáo/thuyết trình có trình bày sạch đẹp, bao gồm cả bảng biểu/dashboard. Có thể xuất ra nhiều định dạng (PDF, HTML, Word, website như tài liệu này, etc.) Có thể tích hợp nhiều ngôn ngữ như R, Python, SQL. Kết hợp cả code, comment, phân tích, biểu đồ trong cùng 1 văn bản. Điểm bất cập duy nhất của R Mả là khó sử dụng hơn script, vì vậy chúng ta sẽ không đề cập đến R Mả quá nhiều. Tuy nhiên, học cách sử dụng R Mả là rất quan trọng để đi lên một tầm cao mới trong nghiên cứu và làm việc. 1.6.1 R Script (file đuôi *.R) Định dạng script truyền thống được tạo ra bằng cách vào menu File -&gt; New File -&gt; R Script trong RStudio. Một cửa sổ mới được mở ra trong RStudio và bạn có thể gõ các hàm vào giống như đang sử dụng Word hoặc Notepad. Để chạy dòng lệnh hiện tại (có trỏ chuột/cursor ở dòng đó), ấn nút Run ở góc trên phải bên cửa sổ script, hoặc dùng phím tắt Ctrl+Enter (trên Windows). Ngoài ra, bạn có thể chọn (highlight) một đoạn code rồi ấn Run hoặc Ctrl+Enter để chạy riêng đoạn đó. Để chạy toàn bộ cả script, ấn nút Source, hoặc highlight (Ctrl+A) toàn bộ code rồi dùng Ctrl+Enter. Thông thường một R Script sẽ nhìn như thế này: # ví dụ về comment: có thể dùng để giải thích ý nghĩa đoạn code ở dưới # nguồn tham khảo của code # ghi chú khác x &lt;- c(1:50) # vẽ biểu đồ plot(x, exp(x)) Có thể thấy, đoạn code trên bao gồm 1 số comment giải thích và cuối cùng là một hàm để vẽ biểu đồ. Tuy nhiên, biểu đồ này không được bao gồm luôn trong script mà người dùng phải chạy lại toàn bộ script mỗi lần mở lên xem. Ngoài ra, việc trình bày và giải thích với comment khá rối mắt và luôn phải kèm theo ký tự #. 1.6.2 R Markdown (file đuôi *.Rmd) Thông thường khi làm báo cáo hoặc viết bài nghiên cứu, chúng ta phải tính toán và vẽ biểu đồ trong các phần mềm thống kê, sau đó copy kết quả sang Word hoặc Powerpoint. Việc này khá tốn thời gian và dễ gây nhầm lẫn, trong khi R Markdown có thể vừa giúp chúng ta làm các phân tích trong R, vừa xuất ra kết quả nhanh chóng bằng dạng văn bản. Để tạo văn bản R Markdown, vào menu File -&gt; New File -&gt; R Markdown... của RStudio. Tham khảo thêm về R Markdown ở mục Tham khảo 1.6.3 R Project (file đuôi *.Rproj) Chưa nghĩ ra nên viết gì!! 1.7 Tham khảo Website của R Markdown. R Markdown: Thhe Definitive Guide - tác giả của cuốn sách này cũng là đồng tác giả của R Markdown. Trang GitHub của R Markdown. Hết chương 1!!!!!!!!!!!!! "],
["data-frame.html", "2 Data frame 2.1 Import dữ liệu cơ bản 2.2 Các loại dữ liệu (Value type) 2.3 Truy vấn dữ liệu cơ bản 2.4 Tham khảo", " 2 Data frame Data frame là một loại dữ liệu dạng bảng (tabular data), hay còn gọi là data frames trong R. Về khái niệm, data frame giống như một sheet trong Excel, với nhiều cột và dòng, trong đó mỗi cột đại diện cho 1 trường có cùng kiểu dữ liệu, và mỗi dòng là một observation (bản ghi hoặc quan sát). Các tính chất của data frame: Tên cột không được trống (dòng header đầu tiên). Như vậy, khi truy cập đến các cột trong code, chúng ta sẽ gọi tên thay vì gọi số thứ tự của cột giống như trong Excel (cột A hoặc cột 1). Tên dòng không được lặp lại. Kiểu dữ liệu (value type) trong cột phải là character, numeric hoặc factor (sẽ nhắc đến sau). Độ dài của các cột (số obs) phải bằng nhau. Khi đặt tên (assign) cho data frame, chúng ta sẽ coi đây là 1 object (đối tượng) và không dùng thuật ngữ biến/variable. 2.1 Import dữ liệu cơ bản 2.1.1 Từ package Trong khi tự học R, nhiều giáo trình (như R for Data Science - Hadley Wickham) sẽ mở đầu bằng các bộ dữ liệu từ các package. Trong tài liệu này, chúng ta sẽ sử dụng package nycflights13 để làm mẫu. install.packages(&#39;nycflights13&#39;) Có 2 cách cơ bản để import dữ liệu từ package như sau: Load toàn bộ package chứa dữ liệu bằng hàm library(), khi đó dữ liệu cũng sẽ được import theo. Lưu ý, khi dùng hàm library(), không cần dùng dấu chấm phẩy để gọi tên package giống như hàm install.packages(). library(nycflights13) # Xem thử 10 dòng đầu tiên của bộ dữ liệu &#39;flights&#39; head(flights,10) ## # A tibble: 10 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ... with 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Load riêng dữ liệu cần thiết thay vì load cả package, giúp tiết kiệm bộ nhớ. Hàm data() nhận các arg dưới dạng string, vì vậy cần dấu chấm phẩy. data(&#39;flights&#39;, package = &#39;nycflights13&#39;) head(flights,10) ## # A tibble: 10 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ... with 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Có thể thấy ở trên, ngoài 2 hàm library() và data(), chúng ta còn dùng hàm head() để xem một số lượng nhất định dòng đầu tiên của data frame. Ngoài ra, chúng ta cũng có thể xem toàn bộ data frame này bằng cách dùng hàm View() (lưu ý có viết hoa chữ V đầu tiên). View(flights) Tương tự, khi chúng ta truy cập sửa sổ Environment ở góc trên bên phải, các data frame đã được import cũng hiện ra. Khi đưa trỏ chuột chọn 1 data frame, R cũng ngầm thực hiện hàm View() và sau đó một cửa sổ mới hiện ra thể hiện toàn bộ data frame. 2.1.2 Import từ Excel, file csv hoặc file txt Trong thực tế, dữ liệu thường xuyên được chia sẻ và lưu trữ ở các dạng .csv, .txt hoặc trong file Excel (.xls và .xlsx). Khi mở các loại file này ở bên ngoài (ví dụ trong Excel hoặc 1 text editor nào đó), ta có thể thấy dòng đầu tiên thường là tên cột (dòng header). Khi sử dụng RStudio, chúng ta có thể dùng chức năng Import Dataset ở cửa sổ Environment hoặc qua menu File -&gt; Import Dataset, tuy nhiên cách làm này thủ công và không đáp ứng được tính năng “reproducible”, vì khi chia sẻ code cho người khác, họ sẽ lại phải import data thủ công lại thay vì chỉ cần chạy code. Thay vào đó, chúng ta có thể sử dụng 1 số hàm sau (Lưu ý cách viết tên_package::tên_function là để tránh phải load toàn bộ package ra và chỉ gọi thằng function): dùng hàm readxl::read_excel(): hàm này có các argument quan trọng nhất là path (đường dẫn đến file), sheet (chọn sheet muốn import). Ngoài ra số số arg khác như col_names, col_types, trim_ws cũng khá hữu ích, có thể tham khảo thêm thông qua ?read_excel. dùng hàm readr::read_csv(): tương tự như read_excel, hàm read_csv cũng có argument file (đường dẫn). Hàm này được sử dụng để import file csv. Lưu ý: read_csv() không hỗ trợ row names, nên có lúc import dữ liệu vào sẽ tự động thêm 1 cột row names đầu tiên. dùng hàm readr::read_delim(): hàm này được sử dụng để import file txt; chữ “delim” trong tên hàm là viết tắt của từ “delimiter”: nếu bất kì ai đã từng sử dụng chức năng Import from text trong Excel sẽ hiểu nghĩa từ này. Các argument quan trọng: file (đường dẫn), delim (delimiter: kí hiệu tách cột, ví dụ đối với file csv mặc định là dấu phẩy). 2.2 Các loại dữ liệu (Value type) Data frame trong R yêu cầu mỗi cột có chung một loại dữ liệu thống nhất. Ví dụ, trong cột “Năm sinh”, tất cả dữ liệu phải thuộc dạng số. Dưới đây là các loại dữ liệu thông dụng trong R: Integers (Số nguyên): Là các số \\(\\left(\\dots,-2,-1,0,1,2,\\dots\\right)\\). Để chuyển đổi dữ liệu loại khác sang số nguyên, dùng hàm as.integer(). Numeric: là bất kì loại số nào, kể cả số thập phân. Để chuyển đổi dữ liệu loại khác sang kiểu numeric, dùng hàm as.numeric(). String: Tương ứng với kiểu dữ liệu “Text” trong Excel; là chuỗi các kí tự bất kì, thậm chí có thể là số nhưng được lưu trữ ở dạng string. Dữ liệu kiểu string có thể là tên người, username, password, etc. Sử dụng hàm as.character() để chuyển đổi. Factor: Là kiểu dữ liệu string nằm trong nhóm hữu hạn các giá trị cho trước. Thông thường factor còn được hiểu là biến nhóm (categorical values), tuy nhiên trong R chúng ta sẽ sử dụng thuật ngữ “Factor”. Ví dụ: giới tính (nam, nữ), điểm (A, B, C, E, D, F). Sử dụng hàm as.factor() để chuyển đổi. Logical: Là loại dữ liệu factor đặc biệt, chỉ gồm 2 giá trị TRUE và FALSE. Dùng hàm as.logical() để convert 0 thành FALSE và mọi giá trị số còn lại thành TRUE. Thông thường, khi import dữ liệu, R sẽ tự động đặt kiểu giá trị cho data frame, tuy nhiên nên sử dụng argument col_types để tự đặt theo ý mình, tránh sai sót. 2.3 Truy vấn dữ liệu cơ bản Thực tế, data frame là một list các vector cùng độ dài (Đọc thêm về list ở mục tham khảo - data structures). Vì vậy, ta có thể tự tạo 1 data frame cơ bản bằng cách liệt kê ra các vector. animals &lt;- data.frame( Ten = c(&#39;Cho&#39;, &#39;Meo&#39;, &#39;Lon&#39;, &#39;Ga&#39;), Tuoi = c(3, 5, 1, 1), CanNang_kg = c(15, 8, 30, 3), SoChan = c(4, 4, 4, 2) ) # goi ra data frame animals ## Ten Tuoi CanNang_kg SoChan ## 1 Cho 3 15 4 ## 2 Meo 5 8 4 ## 3 Lon 1 30 4 ## 4 Ga 1 3 2 Để truy vấn một cột trong data frame trên, data dùng cú pháp $: animals$Tuoi ## [1] 3 5 1 1 mean(animals$Tuoi) ## [1] 2.5 Ngoài ra, có thể dùng cú pháp [row, column], tương đương với dòng-cột (ngược lại với cú pháp thông thường trong Excel, ví dụ ô B5): animals[ , &#39;Tuoi&#39;] # xem tất cả các dòng của cột &#39;Tuoi&#39; ## [1] 3 5 1 1 animals[ 2, &#39;Tuoi&#39;] # xem dòng 2 của cột &#39;Tuoi&#39; ## [1] 5 Tương tự, truy vấn dữ liệu bằng số thứ tự (index) cũng theo cú pháp dòng-cột: animals[,2] ## [1] 3 5 1 1 animals[2,2] ## [1] 5 Tạo ra một cột mới: animals$CanNang_g &lt;- animals$CanNang_kg * 1000 # tạo cột cân nặng theo gam animals # truy vấn kết quả ## Ten Tuoi CanNang_kg SoChan CanNang_g ## 1 Cho 3 15 4 15000 ## 2 Meo 5 8 4 8000 ## 3 Lon 1 30 4 30000 ## 4 Ga 1 3 2 3000 Kiểm tra định dạng các biến trong data frame bằng cách dùng hàm str(): str(animals) ## &#39;data.frame&#39;: 4 obs. of 5 variables: ## $ Ten : Factor w/ 4 levels &quot;Cho&quot;,&quot;Ga&quot;,&quot;Lon&quot;,..: 1 4 3 2 ## $ Tuoi : num 3 5 1 1 ## $ CanNang_kg: num 15 8 30 3 ## $ SoChan : num 4 4 4 2 ## $ CanNang_g : num 15000 8000 30000 3000 Hàm summary() giúp đưa ra tóm tắt về data frame, tính toán 1 số thống kê cơ bản như mean, min, max, median, etc. summary(animals) ## Ten Tuoi CanNang_kg SoChan CanNang_g ## Cho:1 Min. :1.0 Min. : 3.00 Min. :2.0 Min. : 3000 ## Ga :1 1st Qu.:1.0 1st Qu.: 6.75 1st Qu.:3.5 1st Qu.: 6750 ## Lon:1 Median :2.0 Median :11.50 Median :4.0 Median :11500 ## Meo:1 Mean :2.5 Mean :14.00 Mean :3.5 Mean :14000 ## 3rd Qu.:3.5 3rd Qu.:18.75 3rd Qu.:4.0 3rd Qu.:18750 ## Max. :5.0 Max. :30.00 Max. :4.0 Max. :30000 2.4 Tham khảo Delimiter - Wiki Comma-separated values - Wiki String - Wiki Data structures - Advanced R "],
["ve-biu-.html", "3 Vẽ biểu đồ 3.1 Các biểu đồ cơ bản 3.2 Tiêu đề và đặt tên trục 3.3 Dán nhãn dữ liệu (annotation) 3.4 Facet 3.5 Các thuật ngữ 3.6 Tham khảo", " 3 Vẽ biểu đồ # load sẵn ggplot2 (đã bao gồm trong tidyverse) library(tidyverse, quietly = TRUE) Do vẽ biểu đồ (graphing) là một mảng phức tạp trong R nói riêng và data analysis/statistics nói chung nên phần này sẽ chỉ dừng ở mức cơ bản. Có một số loại biểu đồ quan trọng nhất như sau: Nhóm Line (geom_path, geom_line, geom_step) Nhóm Point (geom_point, được sử dụng để vẽ các biểu đồ dạng scatterplot) Histogram (geom_freqpoly, geom_histogram, stat_bin) Density (geom_density, stat_density) Boxplot (geom_boxplot, stat_boxplot) Candle chart (không hỗ trợ trong ggplot2) Các biểu đồ đề cập tới trong phần 3 này là scatterplot và boxplot. Các bộ dữ liệu được sử dụng minh họa là iris và mpg. iris là một dataset chứa các observation của 3 loài hoa thuộc chi iris, trong đó độ dài và rộng của cách hoa (petal) và đài hoa (sepal) được đo và ghi lại. data(iris) str(iris) # xem loại dữ liệu ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... Package được sử dụng trong phần này là ggplot2. ggplot2 có rất nhiều công cụ (các hàm) để giúp người dùng vẽ được loại biểu đồ mong muốn (danh sách đầy đủ có ở https://ggplot2.tidyverse.org/reference/). Một biểu đồ sẽ được dựng lên theo từng layer (lớp), với lớp ban đầu là: ggplot(data = iris) ggplot(iris, aes(x = Sepal.Length,y = Sepal.Width)) Có thể thấy cả 2 kết quả trả về là một biểu đồ trống, với kết quả ở dưới có thêm 2 trục x (trục tung) và y (trục hoành). Để thêm một lớp, ta dùng cú pháp chung như sau: ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) Hoặc: ggplot(data = &lt;DATA&gt;, aes(&lt;MAPPINGS&gt;)) + &lt;GEOM_FUNCTION&gt;() Phân biệt cụ thể giữa 2 cú pháp này sẽ giải thích kĩ hơn ở phần nâng cao. Ví dụ với geom_point: p &lt;- ggplot(data = iris, aes(x = Sepal.Length,y = Sepal.Width)) p + geom_point() p + geom_point() + geom_smooth() # Thêm 1 lớp geom_smooth() Lưu ý: Các hàm geom_point() và geom_smooth() không nhận argument nào, và R sẽ tự động thừa kế các argument của hàm ggplot phía trước. Mỗi layer có thể nhận những dataset khác nhau. Layer có thể được thêm vào bằng dấu +. Dataset sử dụng để visualize bắt buộc phải là dạng data frame. 3.1 Các biểu đồ cơ bản 3.1.1 Scatterplot Đây là biểu đồ được dùng để thể hiện mối quan hệ giữa 2 biến liên tục. Cú pháp chung cho biểu dồ scatterplot (?geom_point để đọc thêm documentation): geom_point(mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) Ý nghĩa của các argument: Chú ý rằng các giá trị gán sẵn cho từng argument trong cú pháp trên là giá trị mặc định; nếu không có thiết kệ cụ thể, argument sẽ nhận giá trị mặc định. mapping: Thiết lập 2 trục tung hoành (với aes()). Nếu mapping = NULL (tức là để trống), geom_point nhận mapping từ layer đầu tiên (top level) của plot, tức là từ hàm ggplot trước đó. Nếu không có layer đầu, mapping không thể để trống. data: data frame được dùng. Nếu data = NULL, geom_point nhận data từ layer đầu tiên, tức là từ hàm ggplot trước đó. stat: Biến đổi thống kê sử dụng trong dữ liệu để vẽ đồ thị. position: Điều chỉnh vị trí của đồ thị. …: Những argument khác được pass vào đồ thị. Thông thường là các giá trị qui định về color, size của đồ thị. na.rm: bỏ giá trị NA. Nếu bằng FALSE, hàm sẽ bỏ NA và có cảnh báo (warning). Nếu bằng TRUE, hàm sẽ bỏ NA mà không cảnh báo. show.legend: Có thể hiện layer này trong legend hay không. Mặc định show.legend = NA, tức là có bao gồm trong legend (Còn nhận 1 số value khác, đọc thêm ở doc). inherit.aes: Nếu bằng FALSE, đè lên aestheticis mặc định, thay vì kết hợp với nhau. Trước mắt, chúng ta sẽ chỉ quan tâm đến 2 argument là mapping và data. Ngoài ra argument stat cũng nên được chú ý. Vẽ biểu đồ với x=Sepal.Length và y=Petal.Length: p &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Petal.Length)) p + geom_point() Như đã nói ở trên, geom_point không nhận argument nào, tức là thừa kế từ ggplot (hay nói cách khác, mapping và data bằng NULL và thừa kế từ ggplot, còn các argument còn lại nhận giá trị mặc định). Ta có thể thêm đặc tính (attribute) về màu sắc, với màu sắc thay đổi dựa theo một trường dữ liệu thứ 3 là Species: p + geom_point(aes(color = Species)) Như vậy, không chỉ có trục tung/hoành là có thể nhận dữ liệu mà ta còn gán thêm được các trường dữ liệu khác vào trục. Các tham số về hình dạng của biểu đồ: alpha: Độ trong suốt colour/color: Màu sắc (trong bài này sẽ viết là color) fill: Màu sắc bên trong trong trường hợp có viền bao ngoài group: Các nhóm shape: Hình dạng của point size: Kích thước điểm stroke: Kích thước viền Tuy nhiên, nếu muốn, chúng ta cũng hoàn toàn có thể chỉ gán một giá trị cố định vào các tham số trên, thay vì gán theo trường dữ liệu: p + geom_point( color = &#39;blue&#39;, size = 3) Có thể thấy, nếu gán theo giá trị cố định, các tham số color hay size sẽ không nằm trong hàm aes(): Các tham số bên trong aes() sẽ nhận giá trị là 1 trường dữ liệu (attribute=Column_Name), và thay đổi theo dữ liệu. Các tham số bên ngoài aes() sẽ nhận giá trị cố định (attribute=fixed_value). Một số ví dụ khác: Thay đổi shape dựa theo Species: p + geom_point(aes(shape = Species)) Lồng thêm 3 layer vào nhau: p + geom_point(color = &#39;black&#39;, size = 4.5) + geom_point(color = &#39;pink&#39;, size = 4) + geom_point(color = &#39;black&#39;, size = 1.8) 3.1.2 Boxplot Biểu đồ boxplot, hay còn gọi là box and whiskers, thể hiện 5 thống kê quan trọng: median: trung vị, (đường thẳng ở giữa hình hộp), là giá trị ở giữa của dataset (Q2/0th Percentile). 2 điểm hinge: là 1st quartile và 3rd quartile, là khoảng phần tư thứ nhất và thứ 3 (tứ phân vị), hay nói cách khác là 2 giá trị ở giữa giá trị lớn nhất/nhỏ nhất và giá trị median. 2 điểm whisker: 3.2 Tiêu đề và đặt tên trục Tiêu đề (title) và tên trục (axis labels) 3.3 Dán nhãn dữ liệu (annotation) 3.4 Facet 3.5 Các thuật ngữ Phần này sẽ tổng hợp lại các thuật ngữ bằng tiếng Anh và nghĩa tiếng Việt. 3.6 Tham khảo "],
["bin-i-d-liu.html", "4 Biến đổi dữ liệu 4.1 Giới thiệu chung về dplyr và tibble 4.2 Các “verb” trong dplyr 4.3 Kết hợp các hàm trong dplyr 4.4 Tham khảo", " 4 Biến đổi dữ liệu # load sẵn tidyverse library(tidyverse, quietly = TRUE) Các tool có sẵn trong base R thường không thống nhất và khó sử dụng, nhất là cho người mới học. Vì vậy, chúng ta sẽ sử dụng packagedplyr (Đọc mô tả package tại [http://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html]). 4.1 Giới thiệu chung về dplyr và tibble 4.1.1 Tibble Từ đầu đến giờ, chúng ta đã sử dụng data.frame, tuy nhiên có 1 số điểm mà loại dữ liệu bảng này làm chưa tốt như: Một số chuỗi kỹ tự đặc biệt dạng string bị đổi thành factor khi import. Subset (Lấy các tập hợp con) từ data dạng data.frame có thể bị đổi thành dạng vector hoặc scalar. Tốc độ còn chậm. Vì vậy, dplyr giới thiệu 1 loại dữ liệu bảng mới là tibble. Về cơ bản, tibble giống data.frame nhưng cải thiện ở nhiều điểm. Hiện tại chúng ta có thể tạm bỏ qua những điểm này. 4.1.2 Package dplyr Một điểm đặc biệt của dplyr là hàm pipe %&gt;%, giúp việc viết và đọc code dễ dàng hơn rất nhiều. Ý tưởng của hàm pipe là lấy kết quả của 1 hàm trước đó luôn cho hàm phía sau, tức là thay vì viết f(a,b), ta có thể viết a %&gt;% f(b), dẫn đến 2 lợi ích: Tránh lồng các hàm vào với nhau, ví dụ: nếu bắt đầu bằng x, sau đó dùng hàm f(), tiếp đến hàm g(), rồi đến hàm h(), ta sẽ phải viết h(g(f(x))). Khi đọc đoạn code này, ta sẽ phải đọc từ trong ra ngoài. Khi sử dụng pipe, ta sẽ đọc từ trái sang phải như sau: x %&gt;% f() %&gt;% g() %&gt;% h() Đặt nhiều variable mới: Nếu không lồng các hàm vào với nhau, ta sẽ phải đặt variable mới cho từng hàm. Code Ý nghĩa a %&gt;% f(b) f(a,b) b %&gt;% f(a, .) f(a, b) x %&gt;% f() %&gt;% g() g( f(x) ) Sau mỗi lần nối các hàm với pipe, kết quả luôn là 1 dataset. 4.2 Các “verb” trong dplyr dplyr có 1 hệ thống các hàm, hay còn gọi là các “verb” (động từ) rất thống nhất và khoa học, giúp người mới có thể đọc hiểu và viết code dễ dàng: add_row - Thêm dòng mới. select - Chọn ra các cột theo tên hoặc STT. filter - Chọn ra các dòng theo điều kiện. slice - Chọn ra các dòng theo số dòng. arrange - Sắp xếp lại dòng. mutate&amp; transmute - Thêm cột mới. summarise &amp; group_by - Dùng để pivot dữ liệu. Các hàm trên có cú pháp giống nhau, đều bắt đầu bằng 1 argument dataset đầu vào. Để lấy ví dụ, chúng ta sẽ tạo ra 1 data frame đơn giản làm mẫu, sử dụng hàm tribble() để tạo ra 1 tibble: grades &lt;- tribble( ~Ten, ~GioiTinh, ~HS1, ~HS2, ~CuoiKi, &#39;Nguyet&#39; , &#39;F&#39;, 93, 98, 96, &#39;Truong&#39; , &#39;M&#39;, 99, 90, 80, &#39;Mat&#39; , &#39;M&#39;, 89, 70, 85, &#39;Chuoi&#39; , &#39;M&#39;, 80, 82, 81, &#39;SoyaBean&#39; , &#39;F&#39;, 70, 85, 92, &#39;KhungLong&#39; , &#39;F&#39;, 77, 86, 72) grades ## # A tibble: 6 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nguyet F 93 98 96 ## 2 Truong M 99 90 80 ## 3 Mat M 89 70 85 ## 4 Chuoi M 80 82 81 ## 5 SoyaBean F 70 85 92 ## 6 KhungLong F 77 86 72 4.2.1 add_row() Thêm dòng vào dữ liệu grades ở trên như sau: grades %&gt;% add_row(Ten=&#39;Cuu&#39;, HS1=96, HS2=90) ## # A tibble: 7 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nguyet F 93 98 96 ## 2 Truong M 99 90 80 ## 3 Mat M 89 70 85 ## 4 Chuoi M 80 82 81 ## 5 SoyaBean F 70 85 92 ## 6 KhungLong F 77 86 72 ## 7 Cuu &lt;NA&gt; 96 90 NA grades ## # A tibble: 6 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nguyet F 93 98 96 ## 2 Truong M 99 90 80 ## 3 Mat M 89 70 85 ## 4 Chuoi M 80 82 81 ## 5 SoyaBean F 70 85 92 ## 6 KhungLong F 77 86 72 Các trường thông tin không được thiết lập (như giới tính và điểm cuối kì) sẽ nhận giá trị NA. Vì chúng ta không assign kết quả của câu lệnh trên vào object nào cả, R sẽ in ra luôn kết quả. Dataset grades gốc vẫn không có gì thay đổi. grades &lt;- grades %&gt;% add_row(Ten=&#39;Cuu&#39;, GioiTinh = &#39;F&#39;, HS1=96, HS2=90, CuoiKi = 69) grades ## # A tibble: 7 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nguyet F 93 98 96 ## 2 Truong M 99 90 80 ## 3 Mat M 89 70 85 ## 4 Chuoi M 80 82 81 ## 5 SoyaBean F 70 85 92 ## 6 KhungLong F 77 86 72 ## 7 Cuu F 96 90 69 Câu lệnh trên gán kết quả sau khi thêm dòng vào chính dataset grades, khiến R ghi đè dataset mới lên dataset gốc. 4.2.2 select(), filter() và slice() Các nhóm hàm này cho phép chúng ta chọn ra nhóm những dòng/cột theo điều kiện. 4.2.2.1 select() Hàm select() cho phép chọn ra các cột (hoặc bỏ đi), tương đương với SELECT trong SQL. Chọn cột theo tên: grades %&gt;% select(HS1, HS2) # select by name ## # A tibble: 7 x 2 ## HS1 HS2 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 93 98 ## 2 99 90 ## 3 89 70 ## 4 80 82 ## 5 70 85 ## 6 77 86 ## 7 96 90 Chọn các cột liên tiếp: grades %&gt;% select(HS1:CuoiKi) # select consecutively ## # A tibble: 7 x 3 ## HS1 HS2 CuoiKi ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 93 98 96 ## 2 99 90 80 ## 3 89 70 85 ## 4 80 82 81 ## 5 70 85 92 ## 6 77 86 72 ## 7 96 90 69 Loại ra một hoặc nhiều cột khỏi dataset ban đầu (negative indexing): grades %&gt;% select(-HS2) # negative indexing ## # A tibble: 7 x 4 ## Ten GioiTinh HS1 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nguyet F 93 96 ## 2 Truong M 99 80 ## 3 Mat M 89 85 ## 4 Chuoi M 80 81 ## 5 SoyaBean F 70 92 ## 6 KhungLong F 77 72 ## 7 Cuu F 96 69 Chọn cột theo thứ tự/vị trí: grades %&gt;% select(1:2) # select by index/position ## # A tibble: 7 x 2 ## Ten GioiTinh ## &lt;chr&gt; &lt;chr&gt; ## 1 Nguyet F ## 2 Truong M ## 3 Mat M ## 4 Chuoi M ## 5 SoyaBean F ## 6 KhungLong F ## 7 Cuu F Dùng hàm starts_with() để chọn cột theo điều kiện tên cột: grades %&gt;% select(starts_with(&#39;HS&#39;)) # select by patterns of col name ## # A tibble: 7 x 2 ## HS1 HS2 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 93 98 ## 2 99 90 ## 3 89 70 ## 4 80 82 ## 5 70 85 ## 6 77 86 ## 7 96 90 grades %&gt;% select(starts_with(&#39;HS&#39;), starts_with(&#39;C&#39;)) ## # A tibble: 7 x 3 ## HS1 HS2 CuoiKi ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 93 98 96 ## 2 99 90 80 ## 3 89 70 85 ## 4 80 82 81 ## 5 70 85 92 ## 6 77 86 72 ## 7 96 90 69 grades %&gt;% select(ends_with(&#39;1&#39;)) # áp dụng tương tự với ends_with ## # A tibble: 7 x 1 ## HS1 ## &lt;dbl&gt; ## 1 93 ## 2 99 ## 3 89 ## 4 80 ## 5 70 ## 6 77 ## 7 96 4.2.2.2 filter() Hàm filter() giúp lọc ra các dòng theo điều kiện, giống chức năng filter trong Excel và WHERE trong SQL: grades %&gt;% filter(CuoiKi &gt; 90) ## # A tibble: 2 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nguyet F 93 98 96 ## 2 SoyaBean F 70 85 92 Kết hợp nhiều điều kiện với nhau dùng dấu phẩy , hoặc dùng dấu &amp;: grades %&gt;% filter(HS2 &gt; 90, CuoiKi &gt; 90) ## # A tibble: 1 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nguyet F 93 98 96 grades %&gt;% filter(HS2 &gt; 90 &amp; CuoiKi &gt; 90) ## # A tibble: 1 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nguyet F 93 98 96 Các logical operators trong R: Kí hiệu Ý nghĩa Ghi chú !x (exclaimation) not x (logical negation) Chỉ nên dùng với dữ liệu dạng Logical/boolean x &amp; y (ampersand) x và y (logical AND) Trả kết quả là vector x &amp;&amp; y (double ampersands) x và y (logical AND) Trả kết quả không vectorized x | y (vertical bar) x hoặc y (logical OR, inclusive) Trả kết quả là vector x || y (double vertical bars) x hoặc y (logical OR, inclusive) Trả kết quả không vectorized xor(x, y) exclusive OR Lưu ý về inclusive OR và exclusive OR: inclusive OR: hoặc cái này hoặc cái kia, hoặc cả hai. Ví dụ: Mỗi người có thể sở hữu xe máy hoặc xe hơi, hoặc cả hai. exclusive OR: hoặc cái này hoặc cái kia, nhưng không thể là cả hai. Ví dụ: Mọi số tự nhiên là số chẵn hoặc số lẻ, nhưng không thể là cả hai. Ví dụ: grades %&gt;% filter(HS2 &lt; 90 | CuoiKi &lt; 90) ## # A tibble: 6 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Truong M 99 90 80 ## 2 Mat M 89 70 85 ## 3 Chuoi M 80 82 81 ## 4 SoyaBean F 70 85 92 ## 5 KhungLong F 77 86 72 ## 6 Cuu F 96 90 69 grades %&gt;% filter(xor(HS2 &lt; 90, CuoiKi &lt; 90)) ## # A tibble: 3 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Truong M 99 90 80 ## 2 SoyaBean F 70 85 92 ## 3 Cuu F 96 90 69 4.2.2.3 slice() Hàm slice() cũng lọc ra dòng giống filter(), nhưng dựa vào số thứ tự của dòng (row number): # Lấy dòng đầu tiên grades %&gt;% slice(1) ## # A tibble: 1 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nguyet F 93 98 96 # Lấy 2 dòng đầu tiên grades %&gt;% slice(1:2) ## # A tibble: 2 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nguyet F 93 98 96 ## 2 Truong M 99 90 80 Kết hợp với hàm n(); hàm n() dùng để đếm số lượng quan sát: grades %&gt;% slice(2:n()) ## # A tibble: 6 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Truong M 99 90 80 ## 2 Mat M 89 70 85 ## 3 Chuoi M 80 82 81 ## 4 SoyaBean F 70 85 92 ## 5 KhungLong F 77 86 72 ## 6 Cuu F 96 90 69 Loại bỏ dòng với index âm: grades %&gt;% slice(-3:-n()) ## # A tibble: 2 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nguyet F 93 98 96 ## 2 Truong M 99 90 80 Lưu ý: Hàm n() chỉ sử dụng được khi lồng trong các hàm summarise(), mutate() và filter(). Hàm này không nhận argument nào. 4.2.3 arrange() Cú pháp của hàm: arrange(data, ...). Hàm arrange() mặc định sắp xếp theo thứ tự tăng dần (ascending). Hàm này tương đương với ORDER BY trong SQL. grades %&gt;% arrange(Ten) ## # A tibble: 7 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Chuoi M 80 82 81 ## 2 Cuu F 96 90 69 ## 3 KhungLong F 77 86 72 ## 4 Mat M 89 70 85 ## 5 Nguyet F 93 98 96 ## 6 SoyaBean F 70 85 92 ## 7 Truong M 99 90 80 Sắp xếp giảm dần với desc(): grades %&gt;% arrange(desc(CuoiKi)) ## # A tibble: 7 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nguyet F 93 98 96 ## 2 SoyaBean F 70 85 92 ## 3 Mat M 89 70 85 ## 4 Chuoi M 80 82 81 ## 5 Truong M 99 90 80 ## 6 KhungLong F 77 86 72 ## 7 Cuu F 96 90 69 Kết hợp nhiều điều kiện xếp: grades %&gt;% arrange(HS2, desc(CuoiKi)) ## # A tibble: 7 x 5 ## Ten GioiTinh HS1 HS2 CuoiKi ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mat M 89 70 85 ## 2 Chuoi M 80 82 81 ## 3 SoyaBean F 70 85 92 ## 4 KhungLong F 77 86 72 ## 5 Truong M 99 90 80 ## 6 Cuu F 96 90 69 ## 7 Nguyet F 93 98 96 4.2.4 mutate() &amp; transmute() 4.2.4.1 mutate() Hàm mutate() tạo ra cột mới hoặc update cột có sẵn trong dataset. Ta có thể tạo ra nhiều cột trong cùng 1 hàm mutate(), và thậm chí có thể dùng cột vừa tạo ở trước đó để làm cơ sở tính cho cột tiếp theo. Ta có thể thêm những cột đơn giản như mutate(random_col = 1) để thêm cột chỉ có giá trị 1, hoặc kết hợp với các hàm if_else và case_when để đưa vào các điều kiện phức tạp hơn. Tạo thêm cột điểm tổng kết và xếp hạng, sau đó gán lại vào dataset cũ: grades &lt;- grades %&gt;% mutate( TongKet = (HS1 + HS2*2 + CuoiKi*3)/6, XepHang = cut(TongKet, c(0, 40, 60, 70, 80, 90, 100), c(&#39;Yeu&#39;, &#39;TB&#39;, &#39;TB Kha&#39;, &#39;Kha&#39;, &#39;Gioi&#39;, &#39;XS&#39;))) %&gt;% arrange(TongKet) grades ## # A tibble: 7 x 7 ## Ten GioiTinh HS1 HS2 CuoiKi TongKet XepHang ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 KhungLong F 77 86 72 77.5 Kha ## 2 Cuu F 96 90 69 80.5 Gioi ## 3 Mat M 89 70 85 80.7 Gioi ## 4 Chuoi M 80 82 81 81.2 Gioi ## 5 SoyaBean F 70 85 92 86 Gioi ## 6 Truong M 99 90 80 86.5 Gioi ## 7 Nguyet F 93 98 96 96.2 XS str(grades) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 7 obs. of 7 variables: ## $ Ten : chr &quot;KhungLong&quot; &quot;Cuu&quot; &quot;Mat&quot; &quot;Chuoi&quot; ... ## $ GioiTinh: chr &quot;F&quot; &quot;F&quot; &quot;M&quot; &quot;M&quot; ... ## $ HS1 : num 77 96 89 80 70 99 93 ## $ HS2 : num 86 90 70 82 85 90 98 ## $ CuoiKi : num 72 69 85 81 92 80 96 ## $ TongKet : num 77.5 80.5 80.7 81.2 86 ... ## $ XepHang : Factor w/ 6 levels &quot;Yeu&quot;,&quot;TB&quot;,&quot;TB Kha&quot;,..: 4 5 5 5 5 5 6 Kết hợp với if_else: # Thay đổi giá trị của 1 observation nhất định - đổi điểm HS1 của Chuối thành 75 # Lưu ý, cột TongKet đã tạo ra trước đó sẽ không tự đổng thay đổi them giá trị HS1 mới grades &lt;- grades %&gt;% mutate(HS1 = if_else(Ten == &#39;Chuoi&#39;, 75, HS1)) # Nếu Ten không phải là Chuoi, giữ nguyên giá trị của HS1 grades ## # A tibble: 7 x 7 ## Ten GioiTinh HS1 HS2 CuoiKi TongKet XepHang ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 KhungLong F 77 86 72 77.5 Kha ## 2 Cuu F 96 90 69 80.5 Gioi ## 3 Mat M 89 70 85 80.7 Gioi ## 4 Chuoi M 75 82 81 81.2 Gioi ## 5 SoyaBean F 70 85 92 86 Gioi ## 6 Truong M 99 90 80 86.5 Gioi ## 7 Nguyet F 93 98 96 96.2 XS Thay đổi toàn cột giới tính: grades %&gt;% mutate(GioiTinh = if_else(GioiTinh == &#39;M&#39;, &#39;Male&#39;,&#39;Female&#39;)) ## # A tibble: 7 x 7 ## Ten GioiTinh HS1 HS2 CuoiKi TongKet XepHang ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 KhungLong Female 77 86 72 77.5 Kha ## 2 Cuu Female 96 90 69 80.5 Gioi ## 3 Mat Male 89 70 85 80.7 Gioi ## 4 Chuoi Male 75 82 81 81.2 Gioi ## 5 SoyaBean Female 70 85 92 86 Gioi ## 6 Truong Male 99 90 80 86.5 Gioi ## 7 Nguyet Female 93 98 96 96.2 XS Kết hợp nhiều điều kiện: # Lồng (nest) các hàm if_else lại với nhau: grades %&gt;% mutate(Grade = if_else(XepHang == &#39;Yeu&#39;, &#39;F&#39;, if_else(XepHang == &#39;TB&#39;, &#39;D&#39;, if_else(XepHang == &#39;TB Kha&#39;, &#39;C&#39;, if_else(XepHang == &#39;Kha&#39;, &#39;B&#39;, if_else(XepHang == &#39;Gioi&#39;, &#39;A&#39;, &#39;A+&#39;)))))) ## # A tibble: 7 x 8 ## Ten GioiTinh HS1 HS2 CuoiKi TongKet XepHang Grade ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 KhungLong F 77 86 72 77.5 Kha B ## 2 Cuu F 96 90 69 80.5 Gioi A ## 3 Mat M 89 70 85 80.7 Gioi A ## 4 Chuoi M 75 82 81 81.2 Gioi A ## 5 SoyaBean F 70 85 92 86 Gioi A ## 6 Truong M 99 90 80 86.5 Gioi A ## 7 Nguyet F 93 98 96 96.2 XS A+ Lưu ý, hàm dplyr::if_else() khác với hàm base::ifelse(). Hàm thứ 2 của base 2 có rất nhiều giới hạn so với hàm cải tiến của dplyr. Kết hợp với case_when - Về cơ bản, if_else và case_when giống nhau. Điểm khác biệt lớn nhất nằm ở mặt trình bày: Có thể thấy ở ví dụ trên, cách viết nested if_else đọc khá rối mắt. Áp dụng lại với case_when: grades %&gt;% mutate(Grade = case_when(XepHang == &#39;Yeu&#39; ~ &#39;F&#39;, XepHang == &#39;TB&#39; ~ &#39;D&#39;, XepHang == &#39;TB Kha&#39; ~ &#39;C&#39;, XepHang == &#39;Kha&#39; ~ &#39;B&#39;, XepHang == &#39;Gioi&#39; ~ &#39;A&#39;, TRUE ~ &#39;A+&#39;)) # case cuối cùng tương đương với tất cả các trường hợp còn lại ## # A tibble: 7 x 8 ## Ten GioiTinh HS1 HS2 CuoiKi TongKet XepHang Grade ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 KhungLong F 77 86 72 77.5 Kha B ## 2 Cuu F 96 90 69 80.5 Gioi A ## 3 Mat M 89 70 85 80.7 Gioi A ## 4 Chuoi M 75 82 81 81.2 Gioi A ## 5 SoyaBean F 70 85 92 86 Gioi A ## 6 Truong M 99 90 80 86.5 Gioi A ## 7 Nguyet F 93 98 96 96.2 XS A+ 4.2.4.2 transmute() Hàm transmute() cũng tạo ra cột mới, tuy nhiên kết quả đầu ra sẽ chỉ bao gồm những cột vừa được tạo: grades %&gt;% transmute(GioiTinh.VN = if_else(GioiTinh == &#39;M&#39;, &#39;Nam&#39;,&#39;Nu&#39;)) ## # A tibble: 7 x 1 ## GioiTinh.VN ## &lt;chr&gt; ## 1 Nu ## 2 Nu ## 3 Nam ## 4 Nam ## 5 Nu ## 6 Nam ## 7 Nu 4.2.5 summarise() Hàm summarise() nếu dùng riêng lẻ sẽ không thật sự hữu ích. Hàm này tính toán và tóm tắt dataset dựa vào một hoặc nhiều trường dữ liệu, sau đó trả ra kết quả là trường dữ liệu mới với 1 dòng kết quả tóm tắt tương ứng. grades %&gt;% summarise(TB.HS1 = mean(HS1), STD.HS1 = sd(HS1)) ## # A tibble: 1 x 2 ## TB.HS1 STD.HS1 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 85.6 11.4 4.3 Kết hợp các hàm trong dplyr 4.3.1 group_by() Do dataset đang sử dụng chỉ có 7 observation nên việc group thành các nhóm không có ý nghĩa cho lắm. Hàm group_by luôn kết hợp với các hàm khác như mutate(), filter() và summarise(), cho phép nhóm (aggregate) dữ liệu thành các nhóm khác nhau. # Group theo giới tính grades %&gt;% group_by(GioiTinh) %&gt;% summarise(SL = n()) ## # A tibble: 2 x 2 ## GioiTinh SL ## &lt;chr&gt; &lt;int&gt; ## 1 F 4 ## 2 M 3 Chúng ta sẽ sử dụng dataset của OpenIntro về số lượt ném của Kobe Bryant trong series chung kết NBA 2009 (LAL - Lakers vs. ORL - Magic), kéo dài 5 games: kobe &lt;- read_csv(&#39;https://www.openintro.org/stat/data/kobe.csv&#39;, col_types = cols(game = col_integer(), quarter = col_character())) head(kobe,10) Dataset trên có các trường dữ liệu sau: vs: thuộc kiểu string, gồm team mà LAL đối đầu. Dataset này chỉ có ORL. game: thuộc kiểu integer, từ 1 đến 5. quarter: thuộc kiểu character, 1 game bóng rổ có 4 hiệp nhưng có thể có overtime (OT) time: thuộc kiểu character, tuy nhiên vì thời gian trong 1 game bóng rổ đo theo kiểu minute:second:millisecond khiến R hiểu thành hh:mm:ss nên cột này sẽ cần sửa sau (dùng col_character() khiến dữ liệu bị thay đổi). description: thuộc kiểu string, Mô tả từng shot basket: thuộc kiểu string: H tương đương với ném vào - made shot (hit), M tương đương với ném trượt - missed shot (miss). Trong phần dưới, do dataset có 133 observation nên chúng ta sẽ không in thẳng kết quả ra console mà dùng hàm head() để kiểm tra 10 observation đầu tiên. Để kiểm tra toàn bộ dataset, ta dùng hàm View(kobe) hoặc click vào dataset ở cửa sổ Envirronment góc trên bên phải. 4.3.2 Biến đổi dữ liệu cơ bản 4.3.2.1 Các ví dụ cụ thể Có thể thấy trong dataset kobe ở trên: Không có trường dữ liệu ghi lại xem mỗi cú ném tương đương bao nhiêu điểm, chỉ có trường description. Cột quarter vừa có dữ liệu kiểu số (1 đến 4) vừa có kiểu string (1OT, 2OT, etc). Cột time đang hơi rắc rối cho việc xử lý và tính toán sau này. Chúng ta sẽ làm 1 số bước biến đổi dữ liệu như sau. Đổi cột time thành số giây còn lại trong hiệp, kết hợp với hàm paste0() để nối các string lại: # split cột time ra làm 3 cột minute/second/millisecond kobe &lt;- cbind(kobe, kobe %&gt;% transmute(time.s = as.character(time)) %&gt;% separate(time.s, into = paste0(&quot;T&quot;, 1:3), sep = &#39;:&#39;, remove = TRUE)) # có thể thấy cột T3 - millisecond chỉ có giá trị 00, vì vậy ta sẽ loại cột này đi kobe %&gt;% group_by(T3) %&gt;% # kết hợp group_by và summarise, sẽ nói kĩ hơn ở phần sau summarise(n=n()) ## # A tibble: 1 x 2 ## T3 n ## &lt;chr&gt; &lt;int&gt; ## 1 00 133 kobe &lt;- kobe %&gt;% select(-T3) %&gt;% # bỏ T3 mutate(time.s = as.integer(T1) * 60 + as.integer(T2)) %&gt;% # Tạo lại cột time.s ~ số giây còn lại mutate(time = as.character(time)) %&gt;% # đổi định dạng cột time thành string mutate(T1 = as.integer(T1)) %&gt;% rename(time.m = T1) %&gt;% # đổi tên T1 thành time.m ~ số phút còn lại select(-T2) # bỏ T2 head(kobe, 10) ## vs game quarter time ## 1 ORL 1 1 09:47:00 ## 2 ORL 1 1 09:07:00 ## 3 ORL 1 1 08:11:00 ## 4 ORL 1 1 07:41:00 ## 5 ORL 1 1 07:03:00 ## 6 ORL 1 1 06:01:00 ## 7 ORL 1 1 04:07:00 ## 8 ORL 1 1 00:52:00 ## 9 ORL 1 1 00:00:00 ## 10 ORL 1 2 06:35:00 ## description basket time.m ## 1 Kobe Bryant makes 4-foot two point shot H 9 ## 2 Kobe Bryant misses jumper M 9 ## 3 Kobe Bryant misses 7-foot jumper M 8 ## 4 Kobe Bryant makes 16-foot jumper (Derek Fisher assists) H 7 ## 5 Kobe Bryant makes driving layup H 7 ## 6 Kobe Bryant misses jumper M 6 ## 7 Kobe Bryant misses 12-foot jumper M 4 ## 8 Kobe Bryant misses 19-foot jumper M 0 ## 9 Kobe Bryant misses layup M 0 ## 10 Kobe Bryant makes jumper H 6 ## time.s ## 1 587 ## 2 547 ## 3 491 ## 4 461 ## 5 423 ## 6 361 ## 7 247 ## 8 52 ## 9 0 ## 10 395 Ngược lại, ta cũng có thể dùng hàm %/% (là hàm để lấy phần nguyên của phép chia) và %% (lấy phần dư) để tính ngược lại từ trường time.s về dạng second:millisecond: transmute(kobe, time.x = time.s %/% 60 + (time.s %% 60)/100) ## time.x ## 1 9.47 ## 2 9.07 ## 3 8.11 ## 4 7.41 ## 5 7.03 ## 6 6.01 ## 7 4.07 ## 8 0.52 ## 9 0.00 ## 10 6.35 ## 11 5.58 ## 12 5.22 ## 13 4.37 ## 14 3.30 ## 15 2.55 ## 16 1.55 ## 17 0.38 ## 18 0.04 ## 19 11.44 ## 20 11.15 ## 21 10.14 ## 22 9.15 ## 23 6.43 ## 24 4.58 ## 25 4.24 ## 26 3.55 ## 27 3.16 ## 28 1.15 ## 29 0.00 ## 30 6.48 ## 31 6.16 ## 32 5.48 ## 33 2.54 ## 34 1.59 ## 35 11.32 ## 36 5.09 ## 37 4.35 ## 38 0.01 ## 39 1.52 ## 40 11.18 ## 41 9.52 ## 42 9.23 ## 43 8.48 ## 44 4.37 ## 45 4.07 ## 46 3.29 ## 47 1.20 ## 48 0.45 ## 49 0.00 ## 50 7.09 ## 51 5.37 ## 52 1.54 ## 53 1.10 ## 54 4.13 ## 55 2.17 ## 56 11.19 ## 57 8.29 ## 58 7.01 ## 59 6.03 ## 60 5.16 ## 61 3.02 ## 62 0.19 ## 63 5.37 ## 64 4.01 ## 65 3.15 ## 66 2.08 ## 67 0.39 ## 68 9.17 ## 69 7.24 ## 70 7.13 ## 71 5.30 ## 72 0.51 ## 73 0.04 ## 74 8.52 ## 75 7.24 ## 76 6.26 ## 77 5.20 ## 78 4.48 ## 79 3.33 ## 80 1.02 ## 81 4.13 ## 82 3.32 ## 83 2.49 ## 84 1.58 ## 85 0.47 ## 86 11.00 ## 87 9.56 ## 88 5.20 ## 89 4.48 ## 90 3.48 ## 91 1.13 ## 92 7.54 ## 93 6.48 ## 94 6.28 ## 95 4.43 ## 96 0.25 ## 97 9.00 ## 98 5.52 ## 99 2.17 ## 100 11.00 ## 101 9.56 ## 102 9.06 ## 103 8.18 ## 104 6.22 ## 105 4.26 ## 106 3.12 ## 107 2.38 ## 108 2.06 ## 109 5.41 ## 110 5.09 ## 111 4.42 ## 112 3.37 ## 113 3.07 ## 114 2.00 ## 115 1.18 ## 116 0.34 ## 117 0.30 ## 118 0.00 ## 119 6.55 ## 120 3.13 ## 121 0.53 ## 122 0.41 ## 123 0.02 ## 124 9.29 ## 125 5.55 ## 126 1.20 ## 127 0.01 ## 128 3.57 ## 129 3.33 ## 130 2.02 ## 131 0.23 ## 132 0.06 ## 133 0.00 Sửa cột quarter, sử dụng hàm nchar() để đếm số ký tự trong string và hàm substr() để cắt string từ bên trái: # Chuyển 1OT thành 5, 2OT thành 6 , etc. kobe &lt;- kobe %&gt;% # nếu độ dài string = 1 -&gt; đổi thành dạng numeric mutate(quarter.n = case_when(nchar(quarter) == 1 ~ as.numeric(quarter), # nếu độ dài string = 3 -&gt; cột thêm 4 TRUE ~ as.numeric(substr(quarter, 1, 1)) + 4)) head(kobe, 10) ## vs game quarter time ## 1 ORL 1 1 09:47:00 ## 2 ORL 1 1 09:07:00 ## 3 ORL 1 1 08:11:00 ## 4 ORL 1 1 07:41:00 ## 5 ORL 1 1 07:03:00 ## 6 ORL 1 1 06:01:00 ## 7 ORL 1 1 04:07:00 ## 8 ORL 1 1 00:52:00 ## 9 ORL 1 1 00:00:00 ## 10 ORL 1 2 06:35:00 ## description basket time.m ## 1 Kobe Bryant makes 4-foot two point shot H 9 ## 2 Kobe Bryant misses jumper M 9 ## 3 Kobe Bryant misses 7-foot jumper M 8 ## 4 Kobe Bryant makes 16-foot jumper (Derek Fisher assists) H 7 ## 5 Kobe Bryant makes driving layup H 7 ## 6 Kobe Bryant misses jumper M 6 ## 7 Kobe Bryant misses 12-foot jumper M 4 ## 8 Kobe Bryant misses 19-foot jumper M 0 ## 9 Kobe Bryant misses layup M 0 ## 10 Kobe Bryant makes jumper H 6 ## time.s quarter.n ## 1 587 1 ## 2 547 1 ## 3 491 1 ## 4 461 1 ## 5 423 1 ## 6 361 1 ## 7 247 1 ## 8 52 1 ## 9 0 1 ## 10 395 2 Thêm cột điểm point Vì dataset khá nhỏ và việc manipulate string cũng khá phức tạp nên chúng ta sẽ bắt đầu thủ công bằng cách scan dataset sẽ đưa ra được 1 số kết luận như sau: Dataset này không bao gồm ném phạt (free throws), và chỉ bao gồm field goal attempts, tương đương với 2 hoặc 3 điểm Các cú ném 3 điểm sẽ bao gồm đoạn string “3pt” hoặc “three point”, và ta chắc chắn được ra 2 đoạn string này đủ unique để indentify từng shot attempt là 2 hay 3 điểm. Đồng thời, khoảng cách từ vạch 3 điểm đến rổ là 23.75ft (22ft từ góc sân), vì vậy ở dữ liệu cho game 1-2-4-5, phần description đã bao gồm đầy đủ thông tin phân loại 3 điểm (dựa vào thông tin khoảng cách của shot). Từ 2 kết luận trên, ta có thể tạo thêm cột point.attempt, sử dụng hàm grepl(string_to_find, value, ...) trả về giá trị TRUE/FALSE để tìm kiếm các quan sát tương đương với 3 điểm: kobe &lt;- kobe %&gt;% mutate(point.attempt = case_when(grepl(&#39;3pt&#39;, description, fixed = TRUE) == TRUE ~ 3, grepl(&#39;three point&#39;, description, fixed = TRUE) == TRUE ~ 3, TRUE ~ 2)) head(kobe, 10) ## vs game quarter time ## 1 ORL 1 1 09:47:00 ## 2 ORL 1 1 09:07:00 ## 3 ORL 1 1 08:11:00 ## 4 ORL 1 1 07:41:00 ## 5 ORL 1 1 07:03:00 ## 6 ORL 1 1 06:01:00 ## 7 ORL 1 1 04:07:00 ## 8 ORL 1 1 00:52:00 ## 9 ORL 1 1 00:00:00 ## 10 ORL 1 2 06:35:00 ## description basket time.m ## 1 Kobe Bryant makes 4-foot two point shot H 9 ## 2 Kobe Bryant misses jumper M 9 ## 3 Kobe Bryant misses 7-foot jumper M 8 ## 4 Kobe Bryant makes 16-foot jumper (Derek Fisher assists) H 7 ## 5 Kobe Bryant makes driving layup H 7 ## 6 Kobe Bryant misses jumper M 6 ## 7 Kobe Bryant misses 12-foot jumper M 4 ## 8 Kobe Bryant misses 19-foot jumper M 0 ## 9 Kobe Bryant misses layup M 0 ## 10 Kobe Bryant makes jumper H 6 ## time.s quarter.n point.attempt ## 1 587 1 2 ## 2 547 1 2 ## 3 491 1 2 ## 4 461 1 2 ## 5 423 1 2 ## 6 361 1 2 ## 7 247 1 2 ## 8 52 1 2 ## 9 0 1 2 ## 10 395 2 2 Đồng thời, để tính toán dễ dàng hơn, ta đổi cột basket sang 1 và 0 để tính dễ hơn, sau đó tạo thêm cột \\(point.made = point.attempt * basket.n\\) kobe &lt;- kobe %&gt;% mutate(basket.n = case_when(basket == &#39;H&#39; ~ 1, TRUE ~ 0), point.made = point.attempt * basket.n) head(kobe, 10) ## vs game quarter time ## 1 ORL 1 1 09:47:00 ## 2 ORL 1 1 09:07:00 ## 3 ORL 1 1 08:11:00 ## 4 ORL 1 1 07:41:00 ## 5 ORL 1 1 07:03:00 ## 6 ORL 1 1 06:01:00 ## 7 ORL 1 1 04:07:00 ## 8 ORL 1 1 00:52:00 ## 9 ORL 1 1 00:00:00 ## 10 ORL 1 2 06:35:00 ## description basket time.m ## 1 Kobe Bryant makes 4-foot two point shot H 9 ## 2 Kobe Bryant misses jumper M 9 ## 3 Kobe Bryant misses 7-foot jumper M 8 ## 4 Kobe Bryant makes 16-foot jumper (Derek Fisher assists) H 7 ## 5 Kobe Bryant makes driving layup H 7 ## 6 Kobe Bryant misses jumper M 6 ## 7 Kobe Bryant misses 12-foot jumper M 4 ## 8 Kobe Bryant misses 19-foot jumper M 0 ## 9 Kobe Bryant misses layup M 0 ## 10 Kobe Bryant makes jumper H 6 ## time.s quarter.n point.attempt basket.n point.made ## 1 587 1 2 1 2 ## 2 547 1 2 0 0 ## 3 491 1 2 0 0 ## 4 461 1 2 1 2 ## 5 423 1 2 1 2 ## 6 361 1 2 0 0 ## 7 247 1 2 0 0 ## 8 52 1 2 0 0 ## 9 0 1 2 0 0 ## 10 395 2 2 1 2 4.3.2.2 Kết hợp toàn bộ với pipe Ta có thể kết hợp tất cả các ví dụ trên thành 1 đoạn script với pipe %&gt;% để ra kết quả cuối như sau: kobe &lt;- read_csv(&#39;https://www.openintro.org/stat/data/kobe.csv&#39;, col_types = cols(game = col_integer(), quarter = col_character())) kobe &lt;- cbind(kobe, kobe %&gt;% transmute(time.s = as.character(time)) %&gt;% separate(time.s, into = paste0(&quot;T&quot;, 1:3), sep = &#39;:&#39;, remove = TRUE)) %&gt;% select(-T3) %&gt;% mutate(time.s = as.integer(T1) * 60 + as.integer(T2)) %&gt;% mutate(time = as.character(time)) %&gt;% mutate(T1 = as.integer(T1)) %&gt;% rename(time.m = T1) %&gt;% select(-T2) %&gt;% mutate(quarter.n = case_when(nchar(quarter) == 1 ~ as.numeric(quarter), TRUE ~ as.numeric(substr(quarter, 1, 1)) + 4), point.attempt = case_when(grepl(&#39;3pt&#39;, description, fixed = TRUE) == TRUE ~ 3, grepl(&#39;three point&#39;, description, fixed = TRUE) == TRUE ~ 3, TRUE ~ 2), basket.n = case_when(basket == &#39;H&#39; ~ 1, TRUE ~ 0), point.made = point.attempt * basket.n) 4.3.3 group_by và summarise Với dataset kobe đã biến đổi cơ bản xong, ta có thể kết hợp group_by và summarise để trả lời 1 số câu hỏi đơn giản: kobe &lt;- arrange(kobe, game) # group theo game kobe %&gt;% group_by(game) %&gt;% summarise(total.fg = sum(basket.n), # tổng số lượt ném thành công total.fga = n(), # tổng số lượt ném total.point = sum(point.made), # tổng số điểm point.per.fga = total.point/total.fga, # điểm trung bình trên mỗi lượt ném avg.fg = mean(basket.n)) # tỷ lệ ném thành công ## # A tibble: 5 x 6 ## game total.fg total.fga total.point point.per.fga avg.fg ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 16 34 32 0.941 0.471 ## 2 2 10 21 21 1 0.476 ## 3 3 11 25 26 1.04 0.44 ## 4 4 11 30 24 0.8 0.367 ## 5 5 10 23 22 0.957 0.435 # group theo game và quarter kobe %&gt;% group_by(game, quarter.n) %&gt;% summarise(total.fg = sum(basket.n), total.fga = n(), total.point = sum(point.made), point.per.fga = total.point/total.fga, avg.fg = mean(basket.n)) ## # A tibble: 22 x 7 ## # Groups: game [5] ## game quarter.n total.fg total.fga total.point point.per.fga avg.fg ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 3 9 6 0.667 0.333 ## 2 1 2 6 9 12 1.33 0.667 ## 3 1 3 6 11 12 1.09 0.545 ## 4 1 4 1 5 2 0.4 0.2 ## 5 2 1 1 4 2 0.5 0.25 ## 6 2 2 1 1 3 3 1 ## 7 2 3 5 10 10 1 0.5 ## 8 2 4 2 4 4 1 0.5 ## 9 2 5 1 2 2 1 0.5 ## 10 3 1 7 10 16 1.6 0.7 ## # ... with 12 more rows 4.3.4 Kết hợp group_by và mutate / filter Thêm 1 số cột accumuated points, accumulated fga, accumulated fg, fg%, point/fga: kobe &lt;- kobe %&gt;% group_by(game) %&gt;% mutate(acc.pts = cumsum(point.made), fga = 1, acc.fga = cumsum(fga), acc.fg = cumsum(basket.n), pct.fg = cummean(basket.n), pts.per.fga = acc.pts/acc.fga) head(kobe, 10) ## # A tibble: 10 x 18 ## # Groups: game [1] ## vs game quarter time description basket time.m time.s quarter.n ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ORL 1 1 09:4~ Kobe Bryan~ H 9 587 1 ## 2 ORL 1 1 09:0~ Kobe Bryan~ M 9 547 1 ## 3 ORL 1 1 08:1~ Kobe Bryan~ M 8 491 1 ## 4 ORL 1 1 07:4~ Kobe Bryan~ H 7 461 1 ## 5 ORL 1 1 07:0~ Kobe Bryan~ H 7 423 1 ## 6 ORL 1 1 06:0~ Kobe Bryan~ M 6 361 1 ## 7 ORL 1 1 04:0~ Kobe Bryan~ M 4 247 1 ## 8 ORL 1 1 00:5~ Kobe Bryan~ M 0 52 1 ## 9 ORL 1 1 00:0~ Kobe Bryan~ M 0 0 1 ## 10 ORL 1 2 06:3~ Kobe Bryan~ H 6 395 2 ## # ... with 9 more variables: point.attempt &lt;dbl&gt;, basket.n &lt;dbl&gt;, ## # point.made &lt;dbl&gt;, acc.pts &lt;dbl&gt;, fga &lt;dbl&gt;, acc.fga &lt;dbl&gt;, ## # acc.fg &lt;dbl&gt;, pct.fg &lt;dbl&gt;, pts.per.fga &lt;dbl&gt; Ta cũng có thể kết hợp với filter để xem performance trong crunch time (tức là 3 phút cuối của những game sát nhau, trong trường hợp này là game 2/3/4): kobe %&gt;% group_by(game) %&gt;% filter(game %in% c(2,3,4), quarter == max(quarter), time.m &lt;3) %&gt;% select(-description, -vs, -time, -basket) %&gt;% head() ## # A tibble: 6 x 14 ## # Groups: game [2] ## game quarter time.m time.s quarter.n point.attempt basket.n point.made ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 4 1 114 4 2 0 0 ## 2 2 4 1 70 4 2 1 2 ## 3 3 4 2 122 4 3 0 0 ## 4 3 4 0 23 4 3 0 0 ## 5 3 4 0 6 4 3 0 0 ## 6 3 4 0 0 4 2 1 2 ## # ... with 6 more variables: acc.pts &lt;dbl&gt;, fga &lt;dbl&gt;, acc.fga &lt;dbl&gt;, ## # acc.fg &lt;dbl&gt;, pct.fg &lt;dbl&gt;, pts.per.fga &lt;dbl&gt; Trong các ví dụ trên, có 2 điểm mới: các hàm cumsum(), cummean() được gọi là window functions (tham khảo ở mục dưới), thường được dùng để tính lũy kế và các ứng dụng tương tự. Một số window function hữu ích khác bao gồm: cumprod(), cummin(), cummax(), cumsum(), cummean(): Các hàm tính lũy kế row_number(), min_rank(), percent_rank(), dense_rank(), cume_dist(): Các hàm xếp hạng (rank) lead() và lag(): Các hàm offset Ký hiệu %in%: Có thể thấy trong ví dụ, hàm này hoạt động giống IN trong SQL, dịch là: nếu các observation trong trường game nằm trong nhóm các giá trị (2, 3, 4). 4.4 Tham khảo Data transformation - R for DS Logical Operators in R dplyr vignettes Window functions Kobe hot hand data - OpenIntro "],
["bin-i-d-liu-phn-2.html", "5 Biến đổi dữ liệu (Phần 2) 5.1 Dataset Czech Financial 5.2 Tham khảo", " 5 Biến đổi dữ liệu (Phần 2) # load sẵn tidyverse library(tidyverse, quietly = TRUE) library(datamodelr, quietly = TRUE) Ở bài trước, chúng ta đã đi qua phần giới thiệu cơ bản về biến đổi dữ liệu trong R thông qua dplyr. Tuy nhiên, trong cả bài, chúng ta chỉ mới làm việc với 1 dataset duy nhất, nhưng trong thực tế, ta sẽ cần kết nối thông tin giữa nhiều dataset hay table khác nhau. Ví dụ, trong Excel, ta sẽ dùng các hàm VLOOKUP/HLOOKUP hoặc INDEX/MATCH. Trong SQL, ta sử dụng các hàm JOIN hoặc UNION. dplyr cũng cung cấp 1 số function để làm điều này, cụ thể là nhóm các hàm join. 5.1 Dataset Czech Financial Trong phần này, chúng ta sẽ sử dụng (thử) dataset Czech Bank Financial. Dataset này là tập hợp thông tin giao dịch tài chính từ 1 ngân hàng ở Czech từ năm 1993 đến 1999. Đây là data thật, đã ẩn danh thông tin khách hàng. Có khoảng 5300 khách hàng cùng 4500 tài khoản, sở hữu gần 900 thẻ tín dụng, đã thực hiện hơn 1 triệu giao dịch và có gần 700 khoản vay. Mọi người có thể truy cập dữ liệu đã được xử lý thô về mặt format tại đây. file_path &lt;- &quot;data/czech_financial_formatted/&quot; file_list &lt;- list.files(path=file_path) for(i in 1:length(file_list)) { assign(gsub(&quot;.csv&quot;, &quot;&quot;, file_list[i]), read.csv(file=paste0(file_path, file_list[i]), row.names=1) ) } Khi làm việc với 5.2 Tham khảo Relational data - R for DS "],
["cu-truc-iu-khin-control-flow.html", "6 Cấu trúc điều khiển (Control flow) 6.1 Biểu thức &amp; phương thức điều kiện (expressions &amp; operators) 6.2 Mệnh đề điều kiện 6.3 Vòng lặp 6.4 Tham khảo", " 6 Cấu trúc điều khiển (Control flow) # load sẵn tidyverse library(tidyverse, quietly = TRUE) Có 2 kiểu cấu trúc điều khiển (control flow) trong R: Sử dụng các mệnh đề điều kiện if và switch, trong đó ở phần này, chúng ta sẽ chỉ đề cập đến if Sử dụng các mệnh đề vòng lặp while, repeat và for 6.1 Biểu thức &amp; phương thức điều kiện (expressions &amp; operators) Biểu thức điều kiện (logical expressions) bao gồm 1 số biểu thức cơ bản như: &lt;, &lt;=, ==, !=, &gt;=, &gt;. Đây là các biểu thức so sánh thường thấy trong toán học, với != tương đương với &lt;&gt; trong 1 số ngôn ngữ khác. Ngoài ra, như đã giới thiệu ở phần trước, R còn có các toán tử điều kiện (logical operators): Kí hiệu Ý nghĩa Ghi chú !x (exclaimation) not x (logical negation) Chỉ nên dùng với dữ liệu dạng Logical/boolean x &amp; y (ampersand) x và y (logical AND) Trả kết quả là vector x &amp;&amp; y (double ampersands) x và y (logical AND) Trả kết quả không vectorized x | y (vertical bar) x hoặc y (logical OR, inclusive) Trả kết quả là vector x || y (double vertical bars) x hoặc y (logical OR, inclusive) Trả kết quả không vectorized xor(x, y) exclusive OR df &lt;- data.frame(A=1:6, B=5:10) df ## A B ## 1 1 5 ## 2 2 6 ## 3 3 7 ## 4 4 8 ## 5 5 9 ## 6 6 10 df %&gt;% mutate(`A==3?` = A == 3, `A&lt;=3?` = A &lt;= 3, `A!=3?` = A != 3, `Not` = ! `A!=3?`) ## A B A==3? A&lt;=3? A!=3? Not ## 1 1 5 FALSE TRUE TRUE FALSE ## 2 2 6 FALSE TRUE TRUE FALSE ## 3 3 7 TRUE TRUE FALSE TRUE ## 4 4 8 FALSE FALSE TRUE FALSE ## 5 5 9 FALSE FALSE TRUE FALSE ## 6 6 10 FALSE FALSE TRUE FALSE Ngoài các toán tử trên, R còn có các hàm any(), all() và which(). Các hàm này có ý nghĩa đúng như tên gọi: any(6:10 &lt;= 7) # Trả về TRUE nếu có bất kì giá trị nào &lt;= 7 (TRUE) ## [1] TRUE all(6:10 &lt;= 7) # Trả về TRUE nếu tất cả mọi giá trị đều &lt;= 7 (FALSE) ## [1] FALSE which(6:10 &lt;= 7) # Trả về vị trí (index) của những giá trị đáp ứng điều kiện ## [1] 1 2 Lưu ý: R đếm (index) bắt đầu từ 1, thể hiện qua kết quả của hàm which() ở trên. Trong một số ngôn ngữ khác như Python, index bắt đầu từ 0 (VBA cũng có 1 số chỗ index từ 0). Ở phần 1.4 trước đó, chúng ta đã làm quen với %in%, tương tự như hàm IN trong SQL. # dùng hàm rep() để repeat các kí tự A B C D df &lt;- data.frame(Letter = rep(c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;), each=2), Value=1:8) df ## Letter Value ## 1 A 1 ## 2 A 2 ## 3 B 3 ## 4 B 4 ## 5 C 5 ## 6 C 6 ## 7 D 7 ## 8 D 8 df %&gt;% filter(Letter %in% c(&#39;A&#39;, &#39;B&#39;)) ## Letter Value ## 1 A 1 ## 2 A 2 ## 3 B 3 ## 4 B 4 6.2 Mệnh đề điều kiện 6.2.1 Trong dplyr Ở phần 1.4 - Biến đổi dữ liệu, chúng ta đã lấy khá nhiều ví dụ về mệnh đề điều kiện if_else() và case_when, vì vậy phần này sẽ không nói quá nhiều nữa. Tuy nhiên, vẫn cần có 1 số lưu ý như sau: 6.2.1.1 if_else() và case_when() Điểm chung của 2 hàm này là cùng thuộc package dplyr, và được tạo ra để làm việc với kiểu dữ liệu vector. Nói chung, 2 hàm này khác nhau không quá nhiều về công dụng (functionality), tuy nhiên qua nhiều thử nghiệm, có thể thấy if_else() nhanh hơn case_when(): # Đoạn code này có tham khảo ở rstudio forum, link ở phần tham khảo microbenchmark::microbenchmark( case_when(1:1000 &lt; 100 ~ &quot;low&quot;, TRUE ~ &quot;high&quot;), if_else(1:1000 &lt; 3, &quot;low&quot;, &quot;high&quot;), ifelse(1:1000 &lt; 3, &quot;low&quot;, &quot;high&quot;) ) ## Unit: microseconds ## expr min lq mean ## case_when(1:1000 &lt; 100 ~ &quot;low&quot;, TRUE ~ &quot;high&quot;) 119.8 125.60 147.220 ## if_else(1:1000 &lt; 3, &quot;low&quot;, &quot;high&quot;) 38.4 39.70 52.351 ## ifelse(1:1000 &lt; 3, &quot;low&quot;, &quot;high&quot;) 195.6 198.55 212.927 ## median uq max neval ## 133.8 160.80 279.5 100 ## 42.1 61.40 152.6 100 ## 201.8 215.75 324.8 100 Như vậy, có thể kết luận là nếu chúng ta chỉ có ý định viết mệnh đề quan hệ với 2 điều kiện TRUE hoặc FALSE, hãy dùng if_else(). Nếu cần dùng nhiều điều kiện, hãy dùng case_when() để code dễ đọc hơn (more readability). 6.2.1.2 if_else() và ifelse() Trong ví dụ dùng microbenchmark ở trên, có thêm 1 hàm là ifelse(). Cần phân biệt hàm này với if_else(): ?ifelse() cho ta thấy đây là 1 hàm thuộc base R, với tốc độ chậm và gặp vấn đề trong việc giữ đúng kiểu dữ liệu. Vì vậy, tốt nhất là nên tránh xa hàm này. 6.2.2 Mệnh if Ngoài các mệnh đề điều kiện ở trên, chúng ta còn có thể dùng hàm if (khác với if_else() hay ifelse()) trong các tình huống cần đánh giá điều kiện phức tạp hơn, và với kiểu dữ liệu scalar (vô hướng, tức là 1 giá trị). Cấu trúc chung của mệnh đề if như sau: # Cơ bản if( kiểm tra điều kiện ){ các biểu thức kết quả } # Bao gồm cả mệnh đề else if( kiểm tra điều kiện ){ các biểu thức kết quả }else{ các biểu thức kết quả } 6.2.3 Tổng hợp lại if_else() và case_when() áp dụng với dữ liệu kiểu vector, và thường kết hợp với các hàm trong dplyr. if áp dụng với dữ liệu kiểu scalar (vô hướng). ifelse() là một hàm của base R và không hiệu quả bằng if_else() hay case_when(), vì vậy có thể bỏ qua. 6.3 Vòng lặp Chúng ta thường phải viết code để thực hiện 1 công việc lặp đi lặp lại nhiều lần. Để làm được điều này, R cho chúng ta các cách để: Cho R biết khi nào thì dừng thực hiện công việc đó (nếu đáp ứng điều kiện) Số lần thực hiện 6.3.1 Vòng lặp while Cấu trúc cơ bản của vòng lặp while while( kiểm tra điều kiện ){ các biểu thức cần lặp lại } R sẽ bắt đầu bằng việc đánh giá điều kiện: Nếu điều kiện đúng, R sẽ thi hành các biểu thức bên trong ngoặc {} một lần. Sau đó, R sẽ lặp lại quá trình này cho đến khi điều kiện không còn đúng nữa. x &lt;- 2 while( x &lt; 10 ){ print( paste(&quot;Giá trị của x hiện đang là:&quot;, x) ) x &lt;- x + 1 # tăng thêm 1 vào biến x ~ biểu thức cập nhật biến điều kiện } ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 2&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 3&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 4&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 5&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 6&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 7&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 8&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 9&quot; Lỗi thường gặp Người dùng vòng lặp while thường gặp 1 lỗi cơ bản là quên không cập nhật biến điều kiện, hay như trong ví dụ ở trên là quên không thêm vào x &lt;- x + 1. Khi dùng while, luôn cần đến 1 biểu thức để cập nhật biến điều kiện, khiến cho điều kiện có thể đạt kết quả FALSE. Nếu không, hàm while sẽ chạy mãi mãi (infinite loop) và có thể gây treo máy. 6.3.2 Vòng lặp for Vòng lặp for là kiểu vòng lặp phổ biến hơn. Khi dùng for, chúng ta cần biết chính xác số lần chạy vòng lặp. cấu trúc chung của for loop như sau: for( item in vector ){ các biểu thức } Ví dụ: for(x in 1:10){ print( paste(&quot;Giá trị của x hiện đang là:&quot;, x) ) } ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 1&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 2&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 3&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 4&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 5&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 6&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 7&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 8&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 9&quot; ## [1] &quot;Giá tr&lt;U+1ECB&gt; c&lt;U+1EE7&gt;a x hi&lt;U+1EC7&gt;n dang là: 10&quot; Trong ví dụ này, x sẽ đi lần lượt từng giá trị trong vector c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), và các biểu thức trong ngoặc {} được thi hành mỗi lần x nhận 1 giá trị. Chúng ta có thể dùng vòng lặp for để tạo ra 10 giá trị đầu tiên của dãy số Fibonacci (được định nghĩa là: \\(F_{n}=F_{n-1}+F_{n-2}\\) với \\(F_{1}=0\\) và \\(F_{2}=1\\)) như sau: F &lt;- rep(NA, 10) # tạo ra 1 dãy 10 giá trị NA F[1] &lt;- 0 # Đặt giá trị cho F1 và F2 F[2] &lt;- 1 for( n in 3:10 ){ # Vòng lặp đi từ F3 F[n] &lt;- F[n-1] + F[n-2] print(F) # in ra quá trình sau mỗi lần tính } ## [1] 0 1 1 NA NA NA NA NA NA NA ## [1] 0 1 1 2 NA NA NA NA NA NA ## [1] 0 1 1 2 3 NA NA NA NA NA ## [1] 0 1 1 2 3 5 NA NA NA NA ## [1] 0 1 1 2 3 5 8 NA NA NA ## [1] 0 1 1 2 3 5 8 13 NA NA ## [1] 0 1 1 2 3 5 8 13 21 NA ## [1] 0 1 1 2 3 5 8 13 21 34 6.3.3 Chú ý Ngoài for và while, chúng ta còn có thể dùng repeat để lặp lại 1 hành động mãi mãi (chúng ta cần cung cấp thêm 1 mệnh đề điều kiện kèm break để dừng vòng lặp) Chúng ta có thể viết lại vòng lặp for sử dụng while, và viết lại while sử dụng repeat, nhưng không thể làm ngược lại. Điều này là vì repeat linh động hơn while, và while linh động hơn for, nhưng linh động cũng đồng nghĩa với việc dễ có lỗ hổng trong điều kiện dẫn đến lỗi hơn. Tốt nhất là chúng ta nên luôn sử dụng những phương pháp chặt chẽ nhất (strict &amp; least flexible) để giải quyết cùng 1 bài toán. Trong các bài toán về data analysis, chúng ta thường sẽ không cần dùng for nhiều vì đã có các hàm map() và apply() cung cấp giải pháp còn chặt chẽ và hiệu quả hơn. Một lý do chủ yếu là do dữ liệu thường luôn ở dạng vector nên về mặt lý thuyết, ta có thể thực hiện 1 lệnh với toàn bộ các phần tử của vector đó thay vì dùng vòng lặp để đi qua từng phần tử một. Tham khảo thêm về control flow tại https://adv-r.hadley.nz/control-flow.html 6.4 Tham khảo if_else vs. ifelse vs. case_when Scalar in mathematics Control flow - Advanced R "],
["faqs-ngn-gon-v-r.html", "7 FAQs ngắn gọn về R 7.1 Các ký hiệu đặc biệt trong R 7.2 Một số câu hỏi khác 7.3 Tham khảo", " 7 FAQs ngắn gọn về R # load sẵn tidyverse library(tidyverse, quietly = TRUE) Phần này có mục đích trả lời 1 số câu hỏi về R, chủ yếu là những quy chuẩn đặc biệt hay những điểm khác biệt của R so với các ngôn gnwx lập trình khác. 7.1 Các ký hiệu đặc biệt trong R Một số operator/ký hiệu trong R như &lt;-, ., % và :: khá đặc biệt, dễ gây ra khó hiểu đối với người lần đầu đọc và học R. Theo cảm nhận cá nhân, tôi thấy code R rất nhiều các ký tự, và khi đọc code, nhiều lúc sẽ thấy ký tự xuất hiện nhiều hơn chữ. 7.1.1 Dấu &lt;- Câu hỏi: Tại sao R lại sử dụng dấu &lt;- thay vì dấu = như ở nhiều ngôn ngữ lập trình khác? 7.1.1.1 Nguồn gốc Ngôn ngữ R có nguồn gốc từ một ngôn ngữ lập trình khác là S. R thừa hưởng rất nhiều từ S, trong đó có ký hiệu &lt;-. Trước đó, S lại thừa hưởng từ một ngôn ngữ khác là APL. APL sử dụng &lt;- vì ngôn ngữ này được phát triển trên một cỗ máy có sử dụng bàn phím chứa nút &lt;-. Vì vậy, các nhà phát triển đã sử dụng luôn ký hiệu này cho mục đích gán biến (Tham khảo thêm tại APL Reference Manual). knitr::include_graphics(&#39;images/APL2-nappaimisto.png&#39;) Figure 7.1: Source: Wikipedia 7.1.1.2 Cách sử dụng &lt;- vốn được sử dụng rộng rãi hơn trong R, và = không được sử dụng với mục đích gán biến cho tới 2001. Trước đó, = chỉ được dùng để đặt tham số trong function: function(arg = &#39;value&#39;) Vào năm 2001, dấu = bắt đầu được đưa vào sử dụng để gán biến, nhằm giúp việc học và dùng R dễ dàng hơn, do rất nhiều các ngôn ngữ lập trình khác cũng dùng dấu = với mục đích tương tự. Ban đầu, dấu &lt;- vẫn có ích hơn dấu = vì một số chức năng chỉ có thể thực hiện với dấu &lt;-, do dấu = còn được sử dụng để gán tham số trong function. Hiện nay, hầu hết các điểm khác biệt giữa 2 dấu &lt;- và = đã không còn tồn tại, và ta có thể sử dụng 2 ký hiệu này thay cho nhau ở hầu hết mọi chỗ. Tuy nhiên, do dấu = vẫn được sử dụng để đặt tham số cho function nên luôn có xung đột về chức năng, vì R sẽ luôn hiểu dấu = trong code đang được dùng để đặt tham số trước tiên, sau đó mới hiểu là dùng để gán biến. Ví dụ: data.frame( a = rnorm(10), b &lt;- rnorm(10) ) ## a b....rnorm.10. ## 1 0.46734183 1.51780055 ## 2 -2.19051049 0.23536821 ## 3 -0.20686632 0.50918230 ## 4 0.03302487 1.71670513 ## 5 1.24403485 0.00831085 ## 6 0.10850216 0.85213428 ## 7 0.66337949 -0.08357718 ## 8 1.18931818 -0.78834199 ## 9 0.50087811 -1.53379960 ## 10 -0.05922706 0.71506205 #Print a a ## Error in eval(expr, envir, enclos): object &#39;a&#39; not found #Print b b ## [1] 1.51780055 0.23536821 0.50918230 1.71670513 0.00831085 ## [6] 0.85213428 -0.08357718 -0.78834199 -1.53379960 0.71506205 Để tránh tình trạng này, ta sẽ phải lồng thêm một lần dấu ngoặc nữa như sau: data.frame( (a = rnorm(10)), b &lt;- rnorm(10) ) Việc này khiến code dài và khó đọc hơn. Ngoài ra, khi sử dụng dấu = để gán biến trong function, biến sẽ chỉ tồn tại ở function level/function scope, và không thể gọi biến ở global scope: median(x=1:20) ## [1] 10.5 x ## Error in eval(expr, envir, enclos): object &#39;x&#39; not found Tóm lại, có thể sử dụng hai dấu = và &lt;- tùy thích theo ý muốn, tuy nhiên vẫn cần lưu ý một số điểm liên quan đến tính thống nhất/tính dễ đọc của code: Tốt nhất là nên sử dụng thống nhất một loại dấu duy nhất xuyên suốt trong code, tránh sử dụng cả hai cùng một lúc. Do dấu &lt;- là quy chuẩn về style của cộng đồng sử dụng R, vì vậy chúng ta cũng nên sử dụng thống nhất &lt;- để gán biến trong code của mình để khi chia sẻ hoặc hợp tác với người khác sẽ dễ dàng hơn. Khi sử dụng &lt;- để gán biến, ta sẽ phân biệt được rõ ràng 3 loại dấu với 3 mục đích khác nhau: dấu &lt;- cho assignment (gán biến), dấu = cho argument (đặt tham số), và dấu == cho logical comparison (so sánh). Dấu &lt;- dễ nhìn và dễ hiểu hơn dấu = vì nó có chỉ hướng gán biến. Ngược lại với x &lt;- 5, ta hoàn toàn có thể gán biến theo chiều 5 -&gt; x. Tuy nhiên cách thứ 2 không được khuyến khích sử dụng. 7.1.2 Dấu . Dấu chấm . trong R xuất hiện rất nhiều, ví dụ như: mean(x, trim = 0, na.rm = FALSE, ...) Trong đó, na.rm có nghĩa là “remove NAs”. Dấu . trong trường hợp này được dùng để ngăn cách tên biến có nhiều từ. Trong nhiều tài liệu hướng dẫn về R, các tác giả cũng thường chọn đặt tên biến nhiều từ có dấu . để ngăn cách, thay vì dùng dấu _ hoặc đặt tên theo kiểu FooBarFooBar, với các chữ cái đầu tiên của từng từ viết hoa. Đây là một quy chuẩn được thừa hưởng từ ngôn ngữ S. Trong S, và trong các phiên bản cũ của R, dấu _ được sử dụng để gán biến, giống dấu &lt;- ở trên, cho đến phiên bản R 1.8. Vì vậy, dấu . được dùng để tách các chữ khi đặt tên. Nếu chuyển từ VBA sang R, chúng ta có thể sẽ thấy lạ vì trong VBA, dấu . được sử dụng để gọi method. Hiện tại trong R, chúng ta có thể thoải mái sử dụng dấu _ khi đặt tên biến và đối tượng, ngoài trừ ký tự đầu tiên. Tuy nhiên, một số tên mặc định trong R như na.rm sẽ vẫn tiếp tục sử dụng dấu . để giúp code của người dùng có thể chạy được ở các phiên bản khác nhau (backward compatibility). 7.1.3 Dấu % Lần đầu đọc code R, nhiều người sẽ thấy khó hiểu và không quen được vì có sự xuất hiện của dấu phần trăm %, ví dụ như %in%, %&gt;%, %*%. Các operator có cú pháp %abc% với hai dấu phần trăm bên ngoài cùng là loại hàm trung tố (infix, giống như hậu tố là suffix và tiền tố là prefix), tức là hàm này sẽ nhận 2 (và chỉ 2) toán hạng (operand) ở trước và ở sau. Ví dụ: dấu + là một hàm infix, và có thể được sử dụng theo kiểu a+b, tức là nhận a ở trước và b ở sau. Tương tự với %in%: 1 %in% c(1:5) ## [1] TRUE Một số infix operator có sẵn trong R: Operator Ý nghĩa %% Modulo %/% Lấy phần nguyên %*% Nhân ma trận %in% Kiểm tra phần tử Để tự tạo các infix operator, ta cũng sử dụng 2 dấu % giống các operator ở trên: `%concat%` &lt;- function(x,y) { paste0(x, y) } &quot;Hello&quot; %concat% &quot; World!&quot; ## [1] &quot;Hello World!&quot; Nhờ vậy mà các package như magrittr đã tận dụng dấu % và chúng ta nhìn thấy ký hiệu này nhiều như vậy. Một điểm đặc biệt là dấu phần trăm % được sử dụng cho phép toán modulo trong toán học, nên để thống nhất với các operator khác, R dùng %% thay thế. 7.1.4 Dấu : và :: Dấu : được dụng cho dãy số; đây cũng là ý nghĩa chung trong toán học của :. 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 Dấu :: thực tế không chỉ được áp dụng trong R mà còn có ở 1 số ngôn ngữ khác như C++ và Ruby. :: dùng để gọi ra các function/method/object có thể gọi được từ một namespace (không gian tên), ví dụ như 1 package. Ví dụ: dplyr::select. Cú pháp kiểu này giống với VBA, ví dụ như Cell(1,1).Select, thay dấu . bằng dấu ::. 7.2 Một số câu hỏi khác 7.2.1 R có thể sử dụng cho các mục đích nào khác ngoài scientific computing không? Ngoài mục đích nghiên cứu và tính toán khoa học, R còn có thể dùng để: Tạo các web application bằng R Shiny Tạo website/blog bằng blogdown Viết tài liệu/bài báo/nghiên cứu bằng bookdown Tuy nhiên R không phù hợp để lập trình các ứng dụng phức tạp như game được (dù có thể dùng Shiny để làm game đơn giản). 7.2.2 Trong R có tồn tại hệ thống/quy chuẩn về “style” (tương đương) PEP8 trong Pythong) không? Vì bản chất của R nên hiện tại không tồn tại một quy chuẩn thống nhất giống PEP8 như Python. Tuy nhiên có thể tham khảo style guide của tidyverse và Google: https://style.tidyverse.org https://google.github.io/styleguide/Rguide.html Để tự động hóa việc điều kiểm tra syntax và style, có thể dùng package lintr. 7.2.3 Có nên sử dụng require để tải package không? Khi đọc code R, chúng ta sẽ thường thấy nhiều người dùng require thay vì dùng library. function require sẽ thử load package function library sẽ trực tiếp load package Như vậy, nếu muốn load 1 package thì nên dùng library(). Nếu có lỗi xảy ra, code sẽ dừng lại ngay lập tức, giúp chúng ta tìm và sửa lỗi dễ hơn. Nếu dùng require và có lỗi khi load package, các đoạn code ở sau sẽ vẫn tiếp tục chạy nếu chưa dùng đến package kia. 7.3 Tham khảo Tidyverse style guide Google style guide library vs require "]
]
